#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
FocusTimer.app -  집중 모드 시스템(hybrid) v2.0.0
통합 로직 + 외부 설정 분리 = 최적의 확장성과 유지보수성
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
import time
import datetime
import os
import sys
import signal
import random
import subprocess
import json
import hashlib
import fcntl
import stat
import socket
import urllib.request
import urllib.error
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import psutil
from dataclasses import dataclass, asdict
from typing import List, Optional, Dict, Any
from datetime import timedelta
import requests

# ----- 앱 경로 설정 -----
APP_ROOT = Path(__file__).parent.parent
RESOURCES_PATH = APP_ROOT / "Resources"

# 앱 내부 가상환경 경로 설정
APP_VENV_PATH = Path(__file__).parent / "venv"
EXTERNAL_VENV_PATH = APP_ROOT.parent / "focus_timer_env"

# Python 경로 설정 (우선순위: 앱 내부 가상환경 > 외부 가상환경 > 시스템 Python)
if (APP_VENV_PATH / "bin" / "python").exists():
    PYTHON_PATH = APP_VENV_PATH / "bin" / "python"
    print(f"🔗 앱 내부 가상환경 사용: {PYTHON_PATH}")
elif (EXTERNAL_VENV_PATH / "bin" / "python").exists():
    PYTHON_PATH = EXTERNAL_VENV_PATH / "bin" / "python"
    print(f"🔗 외부 가상환경 사용: {PYTHON_PATH}")
else:
    PYTHON_PATH = Path("/usr/bin/python3")
    print(f"🔗 시스템 Python 사용: {PYTHON_PATH}")

# ----- 앱 정보 상수 -----
PRODUCT_NAME = "FocusTimer"
VERSION = "2.0.0"

# ----- 시스템 경로 상수 -----
STATE_PATH = "/Library/Application Support/FocusTimer/state.json"
LOG_PATH = "/var/log/FocusTimer/focus_timer.log"

# ----- 설정 관리 클래스 -----
class ConfigManager:
    def __init__(self):
        self.config_path = RESOURCES_PATH / "config.json"
        self.state_path = STATE_PATH
        self.config = self.load_config()
        self.ensure_directories()

    def ensure_directories(self):
        """필요한 디렉토리 생성"""
        os.makedirs(os.path.dirname(self.state_path), exist_ok=True)
        os.makedirs("/var/log/FocusTimer", exist_ok=True)

    def load_config(self):
        """설정 파일 로드"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                return self.get_default_config()
        except Exception as e:
            print(f"설정 로드 실패: {e}")
            return self.get_default_config()

    def get_default_config(self):
        """기본 설정 반환"""
        return {
            "app_info": {
                "name": "FocusTimer",
                "version": "2.0.0",
                "description": "Hybrid 구조 집중 모드 시스템"
            },
            "system_paths": {
                "hosts_file": "/etc/hosts",
                "redirect_ip": "127.0.0.1",
                "backup_path": "/Library/Application Support/FocusTimer/hosts_backup",
                "lock_file": "/Library/Application Support/FocusTimer/focus_timer.lock",
                "log_path": LOG_PATH,
                "pid_file": "/var/run/focus_timer.pid"
            },
            "blocked_websites": {
                "youtube": [
                    "youtube.com", "www.youtube.com", "m.youtube.com", "youtu.be",
                    "youtube-nocookie.com", "www.youtube-nocookie.com",
                    "youtube.googleapis.com", "www.youtube.googleapis.com",
                    "youtubei.googleapis.com", "www.youtubei.googleapis.com",
                    "yt3.ggpht.com", "i.ytimg.com", "ytimg.com", "www.ytimg.com",
                    "googlevideo.com", "www.googlevideo.com",
                    "shorts.youtube.com", "www.shorts.youtube.com"
                ],
                "social_media": [
                    "facebook.com", "www.facebook.com", "instagram.com", "www.instagram.com",
                    "twitter.com", "www.twitter.com", "x.com", "www.x.com",
                    "tiktok.com", "www.tiktok.com", "reddit.com", "www.reddit.com"
                ],
                "gaming": [
                    "twitch.tv", "www.twitch.tv", "discord.com", "www.discord.com",
                    "steamcommunity.com", "www.steamcommunity.com"
                ],
                "entertainment": [
                    "netflix.com", "www.netflix.com", "disneyplus.com", "www.disneyplus.com",
                    "spotify.com", "www.spotify.com"
                ]
            },
            "focus_mode": {
                "default_start_time": "09:00",
                "default_end_time": "18:00",
                "default_difficulty": 1,
                "max_difficulty": 5,
                "max_attempts": 3,
                "auto_restart_browser": True,
                "force_browser_restart": True
            },
            "security": {
                "enable_system_protection": True,
                "enable_file_monitoring": True,
                "enable_firewall_rules": False,
                "enable_dns_cache_flush": True,
                "enable_browser_cache_clear": True,
                "lock_hosts_file": True,
                "monitor_hosts_changes": True,
                "enable_auto_recovery": True
            },
            "gui_settings": {
                "window_size": {
                    "width": 900,
                    "height": 700
                },
                "theme": "clam",
                "auto_refresh_interval": 5,
                "log_lines_to_show": 20,
                "enable_notifications": True
            },
            "browsers": {
                "supported": [
                    "Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"
                ],
                "cache_paths": {
                    "Google Chrome": [
                        "~/Library/Caches/Google/Chrome/Default/Cache",
                        "~/Library/Application Support/Google/Chrome/Default/Cache"
                    ],
                    "Safari": [
                        "~/Library/Caches/com.apple.Safari",
                        "~/Library/Safari/LocalStorage"
                    ]
                }
            }
        }

    def get(self, key_path, default=None):
        """점 표기법으로 설정 값 가져오기"""
        keys = key_path.split('.')
        value = self.config
        try:
            for key in keys:
                value = value[key]
            return value
        except (KeyError, TypeError):
            return default

    def save_config(self):
        """설정 파일 저장"""
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"설정 저장 실패: {e}")

    def get_all_blocked_websites(self):
        """모든 차단할 웹사이트 목록 반환"""
        websites = []
        blocked_sites = self.get("blocked_websites", {})
        if blocked_sites:
            for category, sites in blocked_sites.items():
                if sites:
                    websites.extend(sites)
        return websites

# ----- 전역 설정 인스턴스 -----
config_manager = ConfigManager()

# ----- 전역 상태 클래스 -----
class FocusTimerState:
    def __init__(self):
        self.is_focus_mode = False
        self.focus_start_time = None
        self.focus_end_time = None
        self.is_blocked = False
        self.hosts_hash = None
        self.last_check = None
        self.block_count = 0
        self.bypass_attempts = 0
        self.difficulty_level = 1
        self.failed_attempts = 0

# ----- 로깅 시스템 -----
class Logger:
    def __init__(self, log_file):
        self.log_file = log_file
        self.ensure_log_directory()

    def ensure_log_directory(self):
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)

    def log(self, level, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"

        # 콘솔 출력
        print(log_entry)

        # 파일 로깅
        try:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")
        except:
            pass

# ----- 시스템 레벨 보호 -----
class SystemProtection:
    def __init__(self):
        self.original_hosts_permissions = None
        self.firewall_rules = []
        # 전역 logger 사용 (A코드 방식)
        self.logger = global_logger

    def backup_hosts_permissions(self):
        """hosts 파일 원본 권한 백업"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            if hosts_path:
                stat_info = os.stat(str(hosts_path))
                self.original_hosts_permissions = stat_info.st_mode
                self.logger.log("INFO", "hosts 파일 권한 백업 완료")
        except Exception as e:
            self.logger.log("ERROR", f"hosts 파일 권한 백업 실패: {e}")

    def lock_hosts_file(self):
        """hosts 파일을 읽기 전용으로 잠금"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            if hosts_path:
                os.chmod(str(hosts_path), stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)  # 444
                self.logger.log("INFO", "hosts 파일 잠금 완료")
        except Exception as e:
            self.logger.log("ERROR", f"hosts 파일 잠금 실패: {e}")

    def unlock_hosts_file(self):
        """hosts 파일 잠금 해제"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            if hosts_path:
                if self.original_hosts_permissions:
                    os.chmod(str(hosts_path), self.original_hosts_permissions)
                else:
                    os.chmod(str(hosts_path), stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)  # 644
                self.logger.log("INFO", "hosts 파일 잠금 해제 완료")
        except Exception as e:
            self.logger.log("ERROR", f"hosts 파일 잠금 해제 실패: {e}")

    def setup_firewall_rules(self):
        """방화벽 규칙 설정"""
        if not config_manager.get("security.enable_firewall_rules", False):
            return

        try:
            # pfctl을 사용한 방화벽 규칙 추가
            rules = []
            websites = config_manager.get_all_blocked_websites()

            for domain in websites:
                rules.append(f'block drop out proto tcp to {domain} port 80')
                rules.append(f'block drop out proto tcp to {domain} port 443')

            # 임시 규칙 파일 생성
            rules_file = "/tmp/focus_timer_pf.conf"
            with open(rules_file, "w") as f:
                f.write("\n".join(rules))

            # 방화벽 규칙 적용
            subprocess.run(["sudo", "pfctl", "-f", rules_file], check=True)
            subprocess.run(["sudo", "pfctl", "-e"], check=True)  # 방화벽 활성화

            self.firewall_rules = rules
            self.logger.log("INFO", f"방화벽 규칙 {len(rules)}개 적용 완료")

        except Exception as e:
            self.logger.log("ERROR", f"방화벽 규칙 설정 실패: {e}")

    def remove_firewall_rules(self):
        """방화벽 규칙 제거"""
        if not config_manager.get("security.enable_firewall_rules", False):
            return

        try:
            subprocess.run(["sudo", "pfctl", "-d"], check=True)  # 방화벽 비활성화
            self.logger.log("INFO", "방화벽 규칙 제거 완료")
        except Exception as e:
            self.logger.log("ERROR", f"방화벽 규칙 제거 실패: {e}")

# ----- 지속적 모니터링 -----
class HostsFileMonitor(FileSystemEventHandler):
    def __init__(self, on_modify_callback):
        self.on_modify_callback = on_modify_callback
        self.last_modified = 0
        # 전역 logger 사용 (A코드 방식)
        self.logger = global_logger

    def on_modified(self, event):
        hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
        if event.src_path == hosts_path:
            current_time = time.time()
            if current_time - self.last_modified > 1:  # 중복 이벤트 방지
                self.last_modified = current_time
                self.logger.log("WARNING", "hosts 파일 변경 감지됨")
                self.on_modify_callback()

class FocusTimerMonitor:
    def __init__(self):
        self.observer = None
        self.monitoring = False
        self.system_protection = SystemProtection()
        # 전역 logger 사용 (A코드 방식)
        self.logger = global_logger

    def start_monitoring(self):
        """파일 시스템 모니터링 시작"""
        if not config_manager.get("security.monitor_hosts_changes", True):
            return

        try:
            self.observer = Observer()
            event_handler = HostsFileMonitor(self.handle_hosts_modification)
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            if hosts_path:
                hosts_dir = os.path.dirname(str(hosts_path))
                self.observer.schedule(event_handler, path=hosts_dir, recursive=False)
                self.observer.start()
                self.monitoring = True
                self.logger.log("INFO", "파일 시스템 모니터링 시작")
        except Exception as e:
            self.logger.log("ERROR", f"모니터링 시작 실패: {e}")

    def stop_monitoring(self):
        """파일 시스템 모니터링 중지"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.monitoring = False
            self.logger.log("INFO", "파일 시스템 모니터링 중지")

    def handle_hosts_modification(self):
        """hosts 파일 수정 처리"""
        if state.is_focus_mode and state.is_blocked:
            self.logger.log("WARNING", "집중 모드 중 hosts 파일 수정 시도 감지")
            state.bypass_attempts += 1

            # 자동으로 차단 재적용
            self.reapply_blocking()

            # 보안 강화
            self.enhance_security()

    def reapply_blocking(self):
        """차단 재적용"""
        try:
            # hosts 파일 잠금 해제
            self.system_protection.unlock_hosts_file()

            # 차단 설정 재적용
            block_websites()

            # hosts 파일 다시 잠금
            if config_manager.get("security.lock_hosts_file", True):
                self.system_protection.lock_hosts_file()

            # DNS 캐시 초기화
            if config_manager.get("security.enable_dns_cache_flush", True):
                self.flush_dns_cache()

            self.logger.log("INFO", "차단 재적용 완료")

        except Exception as e:
            self.logger.log("ERROR", f"차단 재적용 실패: {e}")

    def enhance_security(self):
        """보안 강화"""
        try:
            # 방화벽 규칙 강화
            self.system_protection.setup_firewall_rules()

            # 브라우저 강제 재시작
            if config_manager.get("focus_mode.force_browser_restart", True):
                self.restart_browsers()

            # 시스템 알림
            self.send_system_notification("보안 경고", "집중 모드 중 차단 해제 시도가 감지되었습니다.")

            self.logger.log("INFO", "보안 강화 완료")

        except Exception as e:
            self.logger.log("ERROR", f"보안 강화 실패: {e}")

    def flush_dns_cache(self):
        """DNS 캐시 초기화"""
        try:
            subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
            subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
            self.logger.log("INFO", "DNS 캐시 초기화 완료")
        except Exception as e:
            self.logger.log("ERROR", f"DNS 캐시 초기화 실패: {e}")

    def restart_browsers(self):
        """브라우저 강제 재시작 (BrowserManager 사용)"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.restart_browsers()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def send_system_notification(self, title, message):
        """시스템 알림 전송"""
        try:
            subprocess.run([
                "osascript", "-e",
                f'display notification "{message}" with title "{title}"'
            ], capture_output=True)
        except:
            pass

# ----- 브라우저 관리 시스템 -----
class BrowserManager:
    def __init__(self):
        supported_browsers = config_manager.get("browsers.supported")
        self.supported_browsers = supported_browsers if supported_browsers else [
            "Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"
        ]

        cache_paths = config_manager.get("browsers.cache_paths")
        self.cache_paths = cache_paths if cache_paths else {
            "Google Chrome": [
                "~/Library/Caches/Google/Chrome/Default/Cache",
                "~/Library/Application Support/Google/Chrome/Default/Cache",
                "~/Library/Application Support/Google/Chrome/Default/Code Cache",
                "~/Library/Application Support/Google/Chrome/Default/GPUCache"
            ],
            "Safari": [
                "~/Library/Caches/com.apple.Safari",
                "~/Library/Safari/LocalStorage",
                "~/Library/Safari/WebpageIcons.db"
            ],
            "Firefox": [
                "~/Library/Caches/Firefox/Profiles",
                "~/Library/Application Support/Firefox/Profiles"
            ],
            "Whale": [
                "~/Library/Caches/com.naver.whale",
                "~/Library/Application Support/Naver/Whale/Default/Cache"
            ],
            "Microsoft Edge": [
                "~/Library/Caches/com.microsoft.edgemac",
                "~/Library/Application Support/Microsoft Edge/Default/Cache"
            ]
        }

    def get_running_browsers(self):
        """현재 실행 중인 브라우저 목록을 반환"""
        running_browsers = []

        for browser in self.supported_browsers:
            try:
                if browser == "Safari":
                    # Safari는 실제 브라우저 프로세스만 확인
                    result = subprocess.run(["pgrep", "-f", "Safari.app/Contents/MacOS/Safari"],
                                          capture_output=True)
                else:
                    # 다른 브라우저는 기존 방식
                    result = subprocess.run(["pgrep", "-f", browser], capture_output=True)

                if result.returncode == 0:  # 실행 중이면
                    running_browsers.append(browser)

            except Exception as e:
                logger.log("ERROR", f"{browser} 실행 상태 확인 실패: {e}")

        return running_browsers

    def restart_browsers(self):
        """실행 중인 브라우저를 강제로 재시작"""
        running_browsers = self.get_running_browsers()

        if not running_browsers:
            logger.log("INFO", "실행 중인 브라우저가 없습니다.")
            return

        logger.log("INFO", f"브라우저 강제 재시작 시작: {', '.join(running_browsers)}")

        for browser in running_browsers:
            try:
                # 브라우저 종료
                subprocess.run(["osascript", "-e", f'quit app "{browser}"'],
                             capture_output=True, timeout=5)
                time.sleep(2)

                # 강제 종료
                subprocess.run(["pkill", "-f", browser], capture_output=True)
                time.sleep(1)

                # 재시작
                subprocess.run(["open", "-a", browser], capture_output=True)
                time.sleep(3)

                logger.log("INFO", f"{browser} 재시작 완료")

            except Exception as e:
                logger.log("ERROR", f"{browser} 재시작 실패: {e}")

    def force_browser_restart_with_focus(self):
        """집중 모드용 브라우저 강제 재시작"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"집중 모드: 브라우저 강제 재시작 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                try:
                    # 브라우저를 강제 종료
                    subprocess.run(["osascript", "-e", f'quit app "{browser}"'],
                                 capture_output=True, timeout=5)
                    time.sleep(2)

                    # 여전히 실행 중이면 강제 종료
                    result = subprocess.run(["pgrep", "-f", browser], capture_output=True)
                    if result.returncode == 0:
                        subprocess.run(["pkill", "-f", browser], capture_output=True)
                        time.sleep(1)

                    # 브라우저 재시작
                    subprocess.run(["open", "-a", browser], capture_output=True)
                    time.sleep(3)

                    logger.log("INFO", f"{browser} 강제 재시작 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} 강제 재시작 중 오류: {e}")

            logger.log("INFO", "모든 브라우저 강제 재시작 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 강제 재시작 중 오류: {e}")

    def clear_browser_cache(self):
        """실행 중인 브라우저의 캐시만 자동으로 초기화"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                logger.log("INFO", "실행 중인 브라우저가 없습니다.")
                return

            logger.log("INFO", f"브라우저 캐시 초기화 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                if browser in self.cache_paths:
                    for path in self.cache_paths[browser]:
                        expanded_path = os.path.expanduser(path)
                        if os.path.exists(expanded_path):
                            try:
                                subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)
                                logger.log("INFO", f"{browser} 캐시 경로 초기화: {path}")
                            except Exception as e:
                                logger.log("ERROR", f"{browser} 캐시 경로 초기화 실패: {path} - {e}")

            # 시스템 DNS 캐시 초기화
            self.simple_dns_flush()

            logger.log("INFO", "브라우저 캐시 초기화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 캐시 초기화 중 오류: {e}")

    def force_browser_cache_clear(self):
        """실행 중인 브라우저의 캐시만 초기화 (브라우저 종료 없이)"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"브라우저 캐시 강제 초기화 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                try:
                    if browser in self.cache_paths:
                        for path in self.cache_paths[browser]:
                            expanded_path = os.path.expanduser(path)
                            if os.path.exists(expanded_path):
                                subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

                    logger.log("INFO", f"{browser} 강제 캐시 초기화 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} 강제 캐시 초기화 중 오류: {e}")

            logger.log("INFO", "브라우저 강제 캐시 초기화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 강제 캐시 초기화 중 오류: {e}")

    def force_dns_cache_clear(self):
        """브라우저별 DNS 캐시 초기화"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"브라우저 DNS 캐시 초기화 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                try:
                    # 브라우저별 DNS 캐시 초기화
                    if browser == "Google Chrome":
                        chrome_dns_paths = [
                            "~/Library/Application Support/Google/Chrome/Default/Network",
                            "~/Library/Caches/Google/Chrome/Default/Network"
                        ]
                        for path in chrome_dns_paths:
                            expanded_path = os.path.expanduser(path)
                            if os.path.exists(expanded_path):
                                subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

                    elif browser == "Safari":
                        safari_dns_paths = [
                            "~/Library/Caches/com.apple.Safari/WebpageIcons.db",
                            "~/Library/Safari/LocalStorage"
                        ]
                        for path in safari_dns_paths:
                            expanded_path = os.path.expanduser(path)
                            if os.path.exists(expanded_path):
                                subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

                    logger.log("INFO", f"{browser} DNS 캐시 초기화 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} DNS 캐시 초기화 중 오류: {e}")

            logger.log("INFO", "브라우저 DNS 캐시 초기화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 DNS 캐시 초기화 중 오류: {e}")

    def save_browser_sessions(self):
        """브라우저 세션 정보를 저장"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            # 실행 중인 브라우저 목록만 저장
            session_info = {
                "running_browsers": running_browsers,
                "timestamp": datetime.datetime.now().isoformat()
            }

            # 세션 정보를 파일에 저장
            session_path = os.path.expanduser("~/focus_timer_sessions.json")
            with open(session_path, "w") as f:
                json.dump(session_info, f)

            logger.log("INFO", f"브라우저 세션 정보 저장 완료 ({len(running_browsers)}개 브라우저)")

        except Exception as e:
            logger.log("ERROR", f"세션 저장 중 오류: {e}")

    def restore_browser_sessions(self):
        """브라우저 세션을 자동으로 복구"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"브라우저 세션 복구 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                try:
                    # 브라우저 활성화
                    subprocess.run(["osascript", "-e", f'tell application "{browser}" to activate'],
                                 capture_output=True)
                    time.sleep(0.5)

                    # 새 창 닫기 (Cmd+W)
                    for _ in range(3):
                        subprocess.run(["osascript", "-e",
                                      'tell application "System Events" to key code 13 using {command down}'],
                                     capture_output=True)
                        time.sleep(0.1)

                    # 브라우저 활성화 대기
                    time.sleep(1.5)

                    # Cmd+Shift+T로 세션 복구
                    subprocess.run(["osascript", "-e",
                                  'tell application "System Events" to key code 17 using {command down, shift down}'],
                                 capture_output=True)

                    logger.log("INFO", f"{browser} 세션 복구 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} 세션 복구 중 오류: {e}")

            logger.log("INFO", "브라우저 세션 복구 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 세션 복구 중 오류: {e}")

    def simple_dns_flush(self):
        """DNS 캐시만 초기화 (가장 안전하고 빠른 방법)"""
        try:
            subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
            subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
            logger.log("INFO", "DNS 캐시 초기화 완료")
        except Exception as e:
            logger.log("ERROR", f"DNS 캐시 초기화 중 오류: {e}")

    def optimized_browser_clear(self):
        """최적화된 브라우저 조작 (DNS + 새로고침만)"""
        try:
            # DNS 캐시 초기화
            self.simple_dns_flush()

            # 실행 중인 브라우저 새로고침만
            running_browsers = self.get_running_browsers()
            if running_browsers:
                logger.log("INFO", f"브라우저 새로고침 중... ({', '.join(running_browsers)})")
                for browser in running_browsers:
                    try:
                        subprocess.run(["osascript", "-e", f'tell application "{browser}" to activate'],
                                     capture_output=True)
                        time.sleep(1)  # 브라우저 활성화 대기
                        subprocess.run(["osascript", "-e",
                                      'tell application "System Events" to key code 15 using {command down}'],
                                     capture_output=True)
                        logger.log("INFO", f"{browser} 새로고침 완료")
                    except Exception as e:
                        logger.log("ERROR", f"{browser} 새로고침 중 오류: {e}")
                logger.log("INFO", "브라우저 새로고침 완료")
        except Exception as e:
            logger.log("ERROR", f"브라우저 조작 중 오류: {e}")

    def force_browser_restart(self):
        """실행 중인 브라우저를 안전하게 재시작하고 세션 복구"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"브라우저 재시작 중... ({', '.join(running_browsers)})")

            # 브라우저 세션 저장
            self.save_browser_sessions()

            for browser in running_browsers:
                try:
                    # 브라우저를 안전하게 종료 (AppleScript 사용)
                    subprocess.run(["osascript", "-e", f'tell application "{browser}" to quit'],
                                 capture_output=True)
                    time.sleep(2)  # 안전한 종료 대기

                    # 여전히 실행 중이면 강제 종료
                    result = subprocess.run(["pgrep", "-f", browser], capture_output=True)
                    if result.returncode == 0:
                        subprocess.run(["pkill", "-f", browser], capture_output=True)
                        time.sleep(1)

                    # 브라우저 재시작
                    subprocess.run(["open", "-a", browser], capture_output=True)
                    logger.log("INFO", f"{browser} 재시작 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} 재시작 중 오류: {e}")

            # 브라우저 재시작 후 세션 복구
            time.sleep(5)  # 브라우저 로딩 대기
            self.restore_browser_sessions()

            logger.log("INFO", "브라우저 재시작 및 세션 복구 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 재시작 중 오류: {e}")

    def force_browser_refresh(self):
        """실행 중인 브라우저에만 강제 새로고침 신호 전송"""
        try:
            running_browsers = self.get_running_browsers()

            if not running_browsers:
                return

            logger.log("INFO", f"브라우저 새로고침 중... ({', '.join(running_browsers)})")

            for browser in running_browsers:
                try:
                    # 브라우저 활성화
                    subprocess.run(["osascript", "-e", f'tell application "{browser}" to activate'],
                                 capture_output=True)
                    time.sleep(1)  # 브라우저 활성화 대기

                    # 올바른 새로고침 단축키 사용 (Cmd+R) - key code 15 사용
                    subprocess.run(["osascript", "-e",
                                  'tell application "System Events" to key code 15 using {command down}'],
                                 capture_output=True)

                    logger.log("INFO", f"{browser} 새로고침 완료")

                except Exception as e:
                    logger.log("ERROR", f"{browser} 새로고침 중 오류: {e}")

            logger.log("INFO", "브라우저 새로고침 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 새로고침 중 오류: {e}")

    def get_browser_status(self):
        """브라우저 상태 정보 반환"""
        running_browsers = self.get_running_browsers()
        return {
            "running_browsers": running_browsers,
            "total_running": len(running_browsers),
            "supported_browsers": self.supported_browsers,
            "total_supported": len(self.supported_browsers)
        }

    # ----- 집중 모드 연동 브라우저 제어 -----
    def focus_mode_browser_control(self, enable_focus=True):
        """집중 모드 브라우저 제어 (자동화된 통합 제어)"""
        try:
            if enable_focus:
                logger.log("INFO", "집중 모드: 브라우저 강화 제어 시작")

                # 1. 브라우저 세션 저장 (복구용)
                self.save_browser_sessions()

                # 2. 강화된 캐시 초기화
                self.enhanced_cache_clear()

                # 3. 브라우저 강제 재시작 (집중 모드용)
                self.force_browser_restart_with_focus()

                # 4. 브라우저 차단 강화
                self.enhance_browser_blocking()

                # 5. 자동 모니터링 시작
                self.start_browser_monitoring()

                logger.log("INFO", "집중 모드: 브라우저 강화 제어 완료")
            else:
                logger.log("INFO", "집중 모드 해제: 브라우저 제어 복구 시작")

                # 1. 브라우저 모니터링 중지
                self.stop_browser_monitoring()

                # 2. 브라우저 차단 해제
                self.remove_browser_blocking()

                # 3. 브라우저 새로고침만 (재시작 대신)
                self.force_browser_refresh()

                # 4. 브라우저 정상화
                self.normalize_browsers()

                logger.log("INFO", "집중 모드 해제: 브라우저 제어 복구 완료")

        except Exception as e:
            logger.log("ERROR", f"집중 모드 브라우저 제어 실패: {e}")

    def enhanced_cache_clear(self):
        """강화된 캐시 초기화 (집중 모드용)"""
        try:
            logger.log("INFO", "강화된 캐시 초기화 시작")

            # 1. 시스템 DNS 캐시 초기화
            self.simple_dns_flush()

            # 2. 브라우저별 DNS 캐시 초기화
            self.force_dns_cache_clear()

            # 3. 브라우저 캐시 강제 초기화
            self.force_browser_cache_clear()

            # 4. 추가 브라우저 데이터 정리
            self.clear_additional_browser_data()

            logger.log("INFO", "강화된 캐시 초기화 완료")

        except Exception as e:
            logger.log("ERROR", f"강화된 캐시 초기화 실패: {e}")

    def clear_additional_browser_data(self):
        """추가 브라우저 데이터 정리"""
        try:
            running_browsers = self.get_running_browsers()

            for browser in running_browsers:
                if browser == "Google Chrome":
                    # Chrome 추가 데이터 정리
                    chrome_additional_paths = [
                        "~/Library/Application Support/Google/Chrome/Default/History",
                        "~/Library/Application Support/Google/Chrome/Default/Web Data",
                        "~/Library/Application Support/Google/Chrome/Default/Shortcuts"
                    ]
                    for path in chrome_additional_paths:
                        expanded_path = os.path.expanduser(path)
                        if os.path.exists(expanded_path):
                            subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

                elif browser == "Safari":
                    # Safari 추가 데이터 정리
                    safari_additional_paths = [
                        "~/Library/Safari/History.db",
                        "~/Library/Safari/Downloads.plist",
                        "~/Library/Safari/LastSession.plist"
                    ]
                    for path in safari_additional_paths:
                        expanded_path = os.path.expanduser(path)
                        if os.path.exists(expanded_path):
                            subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

            logger.log("INFO", "추가 브라우저 데이터 정리 완료")

        except Exception as e:
            logger.log("ERROR", f"추가 브라우저 데이터 정리 실패: {e}")

    def enhance_browser_blocking(self):
        """브라우저 차단 강화"""
        try:
            logger.log("INFO", "브라우저 차단 강화 시작")

            # 1. 브라우저별 차단 확장 프로그램 설치/활성화
            self.install_browser_extensions()

            # 2. 브라우저 설정 변경
            self.modify_browser_settings()

            # 3. 추가 차단 규칙 적용
            self.apply_additional_blocking_rules()

            logger.log("INFO", "브라우저 차단 강화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 차단 강화 실패: {e}")

    def install_browser_extensions(self):
        """브라우저 확장 프로그램 설치/활성화"""
        try:
            # Chrome 확장 프로그램 (예시)
            chrome_extensions = [
                "cjpalhdlnbpafiamejdnhcphjbkeiagm",  # uBlock Origin
                "nngceckbapebfimnlniiiahkandclblb"   # Block Site
            ]

            # Safari 확장 프로그램 (예시)
            safari_extensions = [
                "com.el1t.uBlock-Safari",
                "com.block-site.safari"
            ]

            logger.log("INFO", "브라우저 확장 프로그램 설치 준비 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 확장 프로그램 설치 실패: {e}")

    def modify_browser_settings(self):
        """브라우저 설정 변경"""
        try:
            running_browsers = self.get_running_browsers()

            for browser in running_browsers:
                if browser == "Google Chrome":
                    # Chrome 설정 변경 (예시)
                    chrome_settings = {
                        "disable_plugins": True,
                        "disable_javascript": False,  # 기본 기능 유지
                        "disable_images": False,
                        "disable_cookies": False
                    }

                elif browser == "Safari":
                    # Safari 설정 변경 (예시)
                    safari_settings = {
                        "disable_plugins": True,
                        "disable_javascript": False,
                        "disable_images": False,
                        "disable_cookies": False
                    }

            logger.log("INFO", "브라우저 설정 변경 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 설정 변경 실패: {e}")

    def apply_additional_blocking_rules(self):
        """추가 차단 규칙 적용"""
        try:
            # 추가 차단할 도메인 목록
            additional_domains = [
                "*.youtube.com",
                "*.facebook.com",
                "*.instagram.com",
                "*.twitter.com",
                "*.netflix.com",
                "*.twitch.tv"
            ]

            # hosts 파일에 추가 차단 규칙 적용
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            redirect_ip = config_manager.get("system_paths.redirect_ip", "127.0.0.1")

            with open(hosts_path, "a") as f:
                f.write("\n# FocusTimer Additional Blocking Rules\n")
                for domain in additional_domains:
                    f.write(f"{redirect_ip} {domain}\n")

            logger.log("INFO", "추가 차단 규칙 적용 완료")

        except Exception as e:
            logger.log("ERROR", f"추가 차단 규칙 적용 실패: {e}")

    def start_browser_monitoring(self):
        """브라우저 모니터링 시작"""
        try:
            logger.log("INFO", "브라우저 모니터링 시작")

            # 브라우저 프로세스 모니터링 시작
            self.browser_monitoring_active = True

            # 주기적 브라우저 상태 체크
            def monitor_browsers():
                while self.browser_monitoring_active:
                    try:
                        running_browsers = self.get_running_browsers()

                        # 새로운 브라우저가 실행되면 차단 적용
                        for browser in running_browsers:
                            if browser not in self.monitored_browsers:
                                self.apply_browser_restrictions(browser)
                                self.monitored_browsers.add(browser)

                        time.sleep(5)  # 5초마다 체크

                    except Exception as e:
                        logger.log("ERROR", f"브라우저 모니터링 오류: {e}")
                        time.sleep(10)

            # 모니터링 스레드 시작
            self.monitoring_thread = threading.Thread(target=monitor_browsers, daemon=True)
            self.monitoring_thread.start()

            logger.log("INFO", "브라우저 모니터링 스레드 시작")

        except Exception as e:
            logger.log("ERROR", f"브라우저 모니터링 시작 실패: {e}")

    def stop_browser_monitoring(self):
        """브라우저 모니터링 중지"""
        try:
            self.browser_monitoring_active = False
            if hasattr(self, 'monitoring_thread'):
                self.monitoring_thread.join(timeout=5)
            logger.log("INFO", "브라우저 모니터링 중지")
        except Exception as e:
            logger.log("ERROR", f"브라우저 모니터링 중지 실패: {e}")

    def apply_browser_restrictions(self, browser):
        """브라우저별 제한 사항 적용"""
        try:
            logger.log("INFO", f"{browser} 제한 사항 적용")

            # 브라우저별 차단 사이트 접근 제한
            if browser == "Google Chrome":
                # Chrome 특화 제한
                pass
            elif browser == "Safari":
                # Safari 특화 제한
                pass

            logger.log("INFO", f"{browser} 제한 사항 적용 완료")

        except Exception as e:
            logger.log("ERROR", f"{browser} 제한 사항 적용 실패: {e}")

    def remove_browser_blocking(self):
        """브라우저 차단 해제"""
        try:
            logger.log("INFO", "브라우저 차단 해제 시작")

            # 1. 추가 차단 규칙 제거
            self.remove_additional_blocking_rules()

            # 2. 브라우저 설정 복구
            self.restore_browser_settings()

            # 3. 확장 프로그램 비활성화
            self.disable_browser_extensions()

            logger.log("INFO", "브라우저 차단 해제 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 차단 해제 실패: {e}")

    def remove_additional_blocking_rules(self):
        """추가 차단 규칙 제거"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")

            with open(hosts_path, "r") as f:
                lines = f.readlines()

            # 추가 차단 규칙 제거
            filtered_lines = []
            skip_section = False

            for line in lines:
                if "# FocusTimer Additional Blocking Rules" in line:
                    skip_section = True
                    continue
                elif skip_section and line.strip() == "":
                    skip_section = False
                    continue
                elif skip_section:
                    continue
                else:
                    filtered_lines.append(line)

            with open(hosts_path, "w") as f:
                f.writelines(filtered_lines)

            logger.log("INFO", "추가 차단 규칙 제거 완료")

        except Exception as e:
            logger.log("ERROR", f"추가 차단 규칙 제거 실패: {e}")

    def restore_browser_settings(self):
        """브라우저 설정 복구"""
        try:
            logger.log("INFO", "브라우저 설정 복구 시작")

            # 브라우저 설정을 기본값으로 복구
            running_browsers = self.get_running_browsers()

            for browser in running_browsers:
                if browser == "Google Chrome":
                    # Chrome 설정 복구
                    pass
                elif browser == "Safari":
                    # Safari 설정 복구
                    pass

            logger.log("INFO", "브라우저 설정 복구 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 설정 복구 실패: {e}")

    def disable_browser_extensions(self):
        """브라우저 확장 프로그램 비활성화"""
        try:
            logger.log("INFO", "브라우저 확장 프로그램 비활성화 시작")

            # 확장 프로그램 비활성화 로직
            # (실제 구현에서는 브라우저별 확장 프로그램 관리 필요)

            logger.log("INFO", "브라우저 확장 프로그램 비활성화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 확장 프로그램 비활성화 실패: {e}")

    def normalize_browsers(self):
        """브라우저 정상화 (간소화된 버전)"""
        try:
            logger.log("INFO", "브라우저 정상화 시작")

            # 1. DNS 캐시 초기화만
            self.simple_dns_flush()

            # 2. 브라우저 상태 확인
            running_browsers = self.get_running_browsers()
            logger.log("INFO", f"정상화된 브라우저: {', '.join(running_browsers)}")

            logger.log("INFO", "브라우저 정상화 완료")

        except Exception as e:
            logger.log("ERROR", f"브라우저 정상화 실패: {e}")

    def __init__(self):
        # 기존 초기화 코드...
        supported_browsers = config_manager.get("browsers.supported")
        self.supported_browsers = supported_browsers if supported_browsers else [
            "Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"
        ]

        cache_paths = config_manager.get("browsers.cache_paths")
        self.cache_paths = cache_paths if cache_paths else {
            "Google Chrome": [
                "~/Library/Caches/Google/Chrome/Default/Cache",
                "~/Library/Application Support/Google/Chrome/Default/Cache",
                "~/Library/Application Support/Google/Chrome/Default/Code Cache",
                "~/Library/Application Support/Google/Chrome/Default/GPUCache"
            ],
            "Safari": [
                "~/Library/Caches/com.apple.Safari",
                "~/Library/Safari/LocalStorage",
                "~/Library/Safari/WebpageIcons.db"
            ],
            "Firefox": [
                "~/Library/Caches/Firefox/Profiles",
                "~/Library/Application Support/Firefox/Profiles"
            ],
            "Whale": [
                "~/Library/Caches/com.naver.whale",
                "~/Library/Application Support/Naver/Whale/Default/Cache"
            ],
            "Microsoft Edge": [
                "~/Library/Caches/com.microsoft.edgemac",
                "~/Library/Application Support/Microsoft Edge/Default/Cache"
            ]
        }

        # 집중 모드 연동을 위한 추가 변수들
        self.browser_monitoring_active = False
        self.monitored_browsers = set()
        self.monitoring_thread = None

# ----- 전역 인스턴스 -----
state = FocusTimerState()
challenge = None
global_browser_manager = BrowserManager()  # 전역 브라우저 관리자

# ----- 로깅 시스템 -----
# 전역 Logger 싱글턴 패턴
global_logger = Logger(config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log"))
logger = global_logger  # 호환성을 위한 별칭

# ----- 알고리즘 문제 시스템 -----
class AlgorithmChallenge:
    def __init__(self):
        self.difficulty_level = config_manager.get("focus_mode.default_difficulty", 1)
        self.max_attempts = config_manager.get("focus_mode.max_attempts", 3)
        self.failed_attempts = 0

    def generate_problem(self):
        """난이도에 따른 알고리즘 문제 생성"""
        if self.difficulty_level == 1:
            # 기본 사칙연산
            a = random.randint(10, 99)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 2:
            # 3자리 수 연산
            a = random.randint(100, 999)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 3:
            # 복합 연산
            a = random.randint(10, 50)
            b = random.randint(5, 20)
            c = random.randint(2, 10)

            answer = (a + b) * c
            return f"({a} + {b}) × {c} = ?", answer

        elif self.difficulty_level == 4:
            # 피보나치 수열
            n = random.randint(5, 10)
            fib_sequence = [0, 1]
            for i in range(2, n + 1):
                fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
            answer = fib_sequence[n]
            return f"피보나치 수열의 {n}번째 수는? (F(0)=0, F(1)=1)", answer

        else:  # 난이도 5
            # 정렬 알고리즘 문제
            numbers = [random.randint(1, 100) for _ in range(5)]
            sorted_numbers = sorted(numbers)
            answer = sorted_numbers[2]  # 중간값
            return f"숫자 {numbers}를 오름차순으로 정렬했을 때 중간값은?", answer

    def increase_difficulty(self):
        """난이도 증가"""
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        if self.difficulty_level < max_difficulty:
            self.difficulty_level += 1
            logger.log("INFO", f"난이도가 {self.difficulty_level}로 증가")

    def ask_challenge(self):
        """알고리즘 문제 출제 및 정답 확인"""
        logger.log("INFO", f"난이도 {self.difficulty_level} 문제 출제")

        attempts = 0
        while attempts < self.max_attempts:
            problem, answer = self.generate_problem()
            print(f"\n📝 문제: {problem}")

            try:
                user_input = input("답: ").strip()

                if user_input.isdigit():
                    user_answer = int(user_input)
                else:
                    print("⚠️ 숫자를 입력해주세요.")
                    attempts += 1
                    continue

                if user_answer == answer:
                    logger.log("INFO", "문제 해결 성공")
                    return True
                else:
                    attempts += 1
                    remaining = self.max_attempts - attempts
                    print(f"❌ 오답입니다. 정답: {answer}")
                    if remaining > 0:
                        print(f"🔄 남은 시도: {remaining}")
                    else:
                        print("🚫 모든 시도 실패!")

            except KeyboardInterrupt:
                print("\n⚠️ 문제 풀이를 중단할 수 없습니다!")
                attempts += 1
            except:
                print("⚠️ 올바른 숫자를 입력해주세요.")
                attempts += 1

        # 모든 시도 실패
        self.failed_attempts += 1
        if self.failed_attempts >= 2:
            self.increase_difficulty()
            self.failed_attempts = 0

        logger.log("WARNING", "문제 해결 실패 - 종료 거부")
        return False

# ----- 다중 차단 레이어 -----
def block_websites():
    """다중 레이어 차단 적용 (브라우저 제어 연동)"""
    try:
        # 1. hosts 파일 차단
        block_hosts_file()

        # 2. 방화벽 규칙 적용
        if config_manager.get("security.enable_firewall_rules", False):
            apply_firewall_rules()

        # 3. DNS 캐시 초기화
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        # 4. 브라우저 캐시 초기화
        if config_manager.get("security.enable_browser_cache_clear", True):
            clear_browser_cache()

        # 5. 브라우저 강화 제어 (집중 모드 연동)
        if config_manager.get("browser_control.enable_focus_mode_integration", True):
            if 'global_browser_manager' in globals():
                global_browser_manager.focus_mode_browser_control(enable_focus=True)
            else:
                browser_manager = BrowserManager()
                browser_manager.focus_mode_browser_control(enable_focus=True)

        state.is_blocked = True
        state.block_count += 1
        logger.log("INFO", "다중 레이어 차단 적용 완료 (브라우저 제어 연동)")

    except Exception as e:
        logger.log("ERROR", f"차단 적용 실패: {e}")

def unblock_websites():
    """다중 레이어 차단 해제 (강화된 집중모드 제한)"""
    try:
        # 강화된 집중모드 제한 체크
        if hasattr(state, 'is_focus_mode') and state.is_focus_mode:
            # 집중모드가 활성화되어 있으면 무조건 차단해제 금지
            logger.log("WARNING", "집중모드 활성화 상태에서 차단해제 시도 차단")

            # 사운드 재생 (가능한 경우)
            try:
                import os
                os.system("afplay /System/Library/Sounds/Basso.aiff")
                os.system("afplay /System/Library/Sounds/Sosumi.aiff")
            except:
                pass

            return False

        # 1. hosts 파일 복구
        restore_hosts_file()

        # 2. 방화벽 규칙 제거
        if config_manager.get("security.enable_firewall_rules", False):
            remove_firewall_rules()

        # 3. DNS 캐시 초기화
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        # 4. 브라우저 제어 복구 (집중 모드 해제)
        if config_manager.get("browser_control.enable_focus_mode_integration", True):
            if 'global_browser_manager' in globals():
                global_browser_manager.focus_mode_browser_control(enable_focus=False)
            else:
                browser_manager = BrowserManager()
                browser_manager.focus_mode_browser_control(enable_focus=False)

        state.is_blocked = False
        logger.log("INFO", "다중 레이어 차단 해제 완료 (브라우저 제어 연동)")

    except Exception as e:
        logger.log("ERROR", f"차단 해제 실패: {e}")

def apply_firewall_rules():
    """방화벽 규칙 적용"""
    try:
        # pfctl을 사용한 방화벽 규칙
        rules = []
        websites = config_manager.get_all_blocked_websites()

        for domain in websites:
            rules.append(f'block drop out proto tcp to {domain} port 80')
            rules.append(f'block drop out proto tcp to {domain} port 443')

        rules_file = "/tmp/focus_timer_pf.conf"
        with open(rules_file, "w") as f:
            f.write("\n".join(rules))

        subprocess.run(["sudo", "pfctl", "-f", rules_file], check=True)
        subprocess.run(["sudo", "pfctl", "-e"], check=True)

        logger.log("INFO", "방화벽 규칙 적용 완료")

    except Exception as e:
        logger.log("ERROR", f"방화벽 규칙 적용 실패: {e}")

def remove_firewall_rules():
    """방화벽 규칙 제거"""
    try:
        subprocess.run(["sudo", "pfctl", "-d"], check=True)
        logger.log("INFO", "방화벽 규칙 제거 완료")
    except Exception as e:
        logger.log("ERROR", f"방화벽 규칙 제거 실패: {e}")

def block_hosts_file():
    """hosts 파일에 차단 설정 추가"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")
        redirect_ip = config_manager.get("system_paths.redirect_ip")
        websites = config_manager.get_all_blocked_websites()

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            # FocusTimer 블록 시작/끝 마커
            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            # 기존 블록 제거
            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                lines = lines[:start_idx] + lines[end_idx + 1:]

            # 새로운 차단 설정 추가
            new_entries = [block_start]
            for site in websites:
                new_entries.append(f"{redirect_ip} {site}\n")
            new_entries.append(block_end)

            # 파일에 쓰기
            file.seek(0)
            file.writelines(lines + new_entries)
            file.truncate()
            file.flush()
            os.fsync(file.fileno())

            logger.log("INFO", "hosts 파일 차단 설정 완료")

    except Exception as e:
        logger.log("ERROR", f"hosts 파일 차단 실패: {e}")

def restore_hosts_file():
    """hosts 파일에서 차단 설정 제거"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                new_lines = lines[:start_idx] + lines[end_idx + 1:]
                file.seek(0)
                file.writelines(new_lines)
                file.truncate()
                file.flush()
                os.fsync(file.fileno())

                logger.log("INFO", "hosts 파일 복구 완료")
            else:
                logger.log("INFO", "차단 설정이 없습니다.")

    except Exception as e:
        logger.log("ERROR", f"hosts 파일 복구 실패: {e}")

def flush_dns_cache():
    """DNS 캐시 초기화"""
    try:
        subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
        subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
        logger.log("INFO", "DNS 캐시 초기화 완료")
    except Exception as e:
        logger.log("ERROR", f"DNS 캐시 초기화 실패: {e}")

def clear_browser_cache():
    """브라우저 캐시 초기화 (BrowserManager 사용)"""
    # 전역 BrowserManager 인스턴스가 있으면 사용, 없으면 새로 생성
    if 'global_browser_manager' in globals():
        global_browser_manager.clear_browser_cache()
    else:
        browser_manager = BrowserManager()
        browser_manager.clear_browser_cache()

# ----- 상태 관리 -----
def save_state():
    """상태 저장"""
    try:
        state_data = {
            "is_focus_mode": state.is_focus_mode,
            "focus_start_time": state.focus_start_time.isoformat() if state.focus_start_time else None,
            "focus_end_time": state.focus_end_time.isoformat() if state.focus_end_time else None,
            "is_blocked": state.is_blocked,
            "block_count": state.block_count,
            "bypass_attempts": state.bypass_attempts,
            "difficulty_level": challenge.difficulty_level if challenge else 1,
            "failed_attempts": challenge.failed_attempts if challenge else 0,
            "last_check": datetime.datetime.now().isoformat()
        }

        with open(config_manager.state_path, "w") as f:
            json.dump(state_data, f, indent=2)

        logger.log("INFO", "상태 저장 완료")

    except Exception as e:
        logger.log("ERROR", f"상태 저장 실패: {e}")

def load_state():
    """상태 불러오기"""
    try:
        if os.path.exists(config_manager.state_path):
            with open(config_manager.state_path, "r") as f:
                state_data = json.load(f)

            state.is_focus_mode = state_data.get("is_focus_mode", False)
            state.is_blocked = state_data.get("is_blocked", False)
            state.block_count = state_data.get("block_count", 0)
            state.bypass_attempts = state_data.get("bypass_attempts", 0)

            if state_data.get("focus_start_time"):
                state.focus_start_time = datetime.datetime.fromisoformat(state_data["focus_start_time"])
            if state_data.get("focus_end_time"):
                state.focus_end_time = datetime.datetime.fromisoformat(state_data["focus_end_time"])

            if challenge:
                challenge.difficulty_level = state_data.get("difficulty_level", 1)
                challenge.failed_attempts = state_data.get("failed_attempts", 0)

            logger.log("INFO", "상태 불러오기 완료")

    except Exception as e:
        logger.log("ERROR", f"상태 불러오기 실패: {e}")

# ----- GUI 애플리케이션 -----
class FocusTimerApp:
    def __init__(self):
        global challenge
        challenge = AlgorithmChallenge()
        self.monitor = FocusTimerMonitor()
        self.browser_manager = BrowserManager()  # 브라우저 관리자 초기화
        self.running = False
        self.monitor_thread = None

        # 브라우저 관리 메서드들을 미리 정의 (GUI 초기화 전)
        self._setup_browser_methods()

        # GUI 초기화
        self.root = tk.Tk()

        # macOS 특화 GUI 설정
        self.setup_macos_gui()
        self.setup_gui()

        # 상태 불러오기
        load_state()

        # 시스템 보호 초기화
        if config_manager.get("security.enable_system_protection", True):
            self.monitor.system_protection.backup_hosts_permissions()

        # 사용자 설정 로드
        self.user_preferences = self.load_user_preferences()

        # 종료 제어 변수
        self.exit_problem_solved = False
        self.exit_problem = None

        # 사운드 시스템 초기화
        self.init_sound_system()

        # 모니터링 시작
        if config_manager.get("security.monitor_hosts_changes", True):
            self.monitor.start_monitoring()

    def _setup_browser_methods(self):
        """브라우저 관리 메서드들을 미리 정의"""
        # ----- 브라우저 관리 메서드 연결 -----
        def restart_browsers(self):
            """브라우저 재시작 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.restart_browsers()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 재시작 실패: {e}")

        def clear_browser_cache(self):
            """브라우저 캐시 초기화 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.clear_browser_cache()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 캐시 초기화 실패: {e}")

        def refresh_browsers(self):
            """브라우저 새로고침 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.force_browser_refresh()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 새로고침 실패: {e}")

        def save_browser_sessions(self):
            """브라우저 세션 저장 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.save_browser_sessions()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 세션 저장 실패: {e}")

        def restore_browser_sessions(self):
            """브라우저 세션 복구 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.restore_browser_sessions()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 세션 복구 실패: {e}")

        def safe_browser_restart(self):
            """안전한 브라우저 재시작 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.force_browser_restart()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"안전한 브라우저 재시작 실패: {e}")

        def flush_dns_cache(self):
            """DNS 캐시 초기화 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.simple_dns_flush()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"DNS 캐시 초기화 실패: {e}")

        def optimized_browser_clear(self):
            """최적화된 브라우저 정리 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.optimized_browser_clear()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"최적화된 브라우저 정리 실패: {e}")

        def refresh_browser_status(self):
            """브라우저 상태 새로고침 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    status = self.browser_manager.get_browser_status()
                    logger.log("INFO", f"브라우저 상태: {status}")
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"브라우저 상태 새로고침 실패: {e}")

        def focus_mode_browser_control(self):
            """집중 모드 브라우저 제어 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.focus_mode_browser_control(enable_focus=True)
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"집중 모드 브라우저 제어 실패: {e}")

        def release_focus_mode_browser(self):
            """집중 모드 브라우저 해제 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.focus_mode_browser_control(enable_focus=False)
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"집중 모드 브라우저 해제 실패: {e}")

        def enhanced_browser_blocking(self):
            """강화된 브라우저 차단 (BrowserManager 연결)"""
            try:
                if hasattr(self, 'browser_manager') and self.browser_manager:
                    self.browser_manager.enhance_browser_blocking()
                else:
                    logger.log("ERROR", "브라우저 관리자가 초기화되지 않았습니다.")
            except Exception as e:
                logger.log("ERROR", f"강화된 브라우저 차단 실패: {e}")

        # 메서드들을 인스턴스에 바인딩
        self.restart_browsers = restart_browsers.__get__(self, type(self))
        self.clear_browser_cache = clear_browser_cache.__get__(self, type(self))
        self.refresh_browsers = refresh_browsers.__get__(self, type(self))
        self.save_browser_sessions = save_browser_sessions.__get__(self, type(self))
        self.restore_browser_sessions = restore_browser_sessions.__get__(self, type(self))
        self.safe_browser_restart = safe_browser_restart.__get__(self, type(self))
        self.flush_dns_cache = flush_dns_cache.__get__(self, type(self))
        self.optimized_browser_clear = optimized_browser_clear.__get__(self, type(self))
        self.refresh_browser_status = refresh_browser_status.__get__(self, type(self))
        self.focus_mode_browser_control = focus_mode_browser_control.__get__(self, type(self))
        self.release_focus_mode_browser = release_focus_mode_browser.__get__(self, type(self))
        self.enhanced_browser_blocking = enhanced_browser_blocking.__get__(self, type(self))



    def setup_macos_gui(self):
        """macOS 특화 GUI 설정"""
        try:
            # macOS에서 GUI 창을 앞으로 가져오기
            self.root.lift()
            self.root.attributes('-topmost', True)
            self.root.after_idle(self.root.attributes, '-topmost', False)

            # macOS 네이티브 메뉴바 설정
            self.root.createcommand('tk::mac::Quit', self.quit_app)
            self.root.createcommand('tk::mac::ShowPreferences', self.show_preferences)

            # 창 크기 조정 가능하게 설정
            self.root.resizable(True, True)

            # 창 닫기 이벤트 바인딩 (종료 방지)
            self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

            # macOS 스타일 적용
            self.root.tk.call('tk', 'scaling', 2.0)  # 고해상도 디스플레이 지원

        except Exception as e:
            logger.log("ERROR", f"macOS GUI 설정 실패: {e}")

    def show_preferences(self):
        """설정 창 표시"""
        # 설정 탭으로 이동하는 로직 추가 가능
        pass

    def setup_gui(self):
        """GUI 설정"""
        app_name = config_manager.get("app_info.name", "FocusTimer")
        app_version = config_manager.get("app_info.version", "2.0.0")

        self.root.title(f"{app_name} v{app_version}")

        window_size = config_manager.get("gui_settings.window_size", {"width": 900, "height": 700})
        self.root.geometry(f"{window_size['width']}x{window_size['height']}")
        self.root.resizable(True, True)

        # 스타일 설정
        style = ttk.Style()
        theme = config_manager.get("gui_settings.theme", "clam")
        style.theme_use(theme)

        # 메뉴바 설정
        self.setup_menu()

        # 메인 프레임
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # 제목
        title_label = ttk.Label(main_frame, text=f"⏰ {app_name}",
                               font=('Helvetica', 20, 'bold'))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))

        # 탭 생성
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))

        # 탭 추가
        self.create_dashboard_tab()
        self.create_timer_tab()
        self.create_browser_tab()  # 브라우저 관리 탭 추가

                                # 알고리즘 시스템 탭 추가 (안전한 자동 구성)
        try:
            # Resources 폴더를 Python 경로에 추가
            if str(RESOURCES_PATH) not in sys.path:
                sys.path.insert(0, str(RESOURCES_PATH))

            # 직접 import 시도 (가장 안전한 방법)
            try:
                from algorithm_tab import AlgorithmTab

                # AlgorithmTab 인스턴스 생성 및 notebook에 삽입
                self.algorithm_tab = AlgorithmTab(self.notebook)
                self.notebook.add(self.algorithm_tab.frame, text="🧮 알고리즘")

                print("✅ 알고리즘 탭이 성공적으로 통합되었습니다. (직접 import)")

            except ImportError as direct_error:
                print(f"❌ 직접 import 실패: {direct_error}")

                # 대체 방법: Safe Import System 시도
                try:
                    from import_utils import get_importer

                    # SafeImporter 인스턴스 가져오기
                    importer = get_importer()

                    # algorithm_tab 모듈 안전하게 import
                    algorithm_tab_module = importer.import_module('algorithm_tab')

                    if algorithm_tab_module and hasattr(algorithm_tab_module, 'AlgorithmTab'):
                        # AlgorithmTab 인스턴스 생성 및 notebook에 삽입
                        self.algorithm_tab = algorithm_tab_module.AlgorithmTab(self.notebook)
                        self.notebook.add(self.algorithm_tab.frame, text="🧮 알고리즘")

                        print("✅ 알고리즘 탭이 성공적으로 통합되었습니다. (Safe Import)")

                    else:
                        print("❌ AlgorithmTab 클래스를 찾을 수 없습니다.")

                except ImportError as safe_error:
                    print(f"❌ Safe Import System도 실패: {safe_error}")
                    print("⚠️ 알고리즘 탭을 로드할 수 없습니다. Resources 폴더의 모듈을 확인해주세요.")

        except Exception as e:
            print(f"❌ 알고리즘 탭 통합 실패: {e}")
            print("⚠️ 예상치 못한 오류가 발생했습니다.")

        self.create_settings_tab()
        self.create_stats_tab()
        self.create_logs_tab()

        # 상태바
        self.status_var = tk.StringVar(value="준비됨")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var,
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))

        # 그리드 가중치
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)

    def setup_menu(self):
        """메뉴바 설정"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # 파일 메뉴
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="파일", menu=file_menu)
        file_menu.add_command(label="설정 내보내기", command=self.export_config)
        file_menu.add_command(label="설정 가져오기", command=self.import_config)
        file_menu.add_separator()
        file_menu.add_command(label="종료", command=self.quit_app)

        # 도구 메뉴
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="도구", menu=tools_menu)
        tools_menu.add_command(label="CLI 모드", command=self.open_cli)
        tools_menu.add_command(label="웹 인터페이스", command=self.open_web)
        tools_menu.add_separator()
        tools_menu.add_command(label="로그 보기", command=self.view_logs)

        # 도움말 메뉴
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="도움말", menu=help_menu)
        help_menu.add_command(label="사용법", command=self.show_help)
        help_menu.add_command(label="정보", command=self.show_about)

    def create_dashboard_tab(self):
        """대시보드 탭"""
        dashboard_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(dashboard_frame, text="📊 대시보드")

        # 현재 상태
        status_frame = ttk.LabelFrame(dashboard_frame, text="📊 현재 상태", padding="10")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.status_label = ttk.Label(status_frame, text="집중 모드 비활성화",
                                     font=('Helvetica', 14))
        self.status_label.grid(row=0, column=0, sticky=tk.W)

        # 시간 표시
        self.time_var = tk.StringVar(value="")
        time_label = ttk.Label(status_frame, textvariable=self.time_var,
                              font=('Helvetica', 10))
        time_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        # 실시간 통계
        stats_frame = ttk.LabelFrame(dashboard_frame, text="📈 실시간 통계", padding="10")
        stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 차단 횟수
        ttk.Label(stats_frame, text="차단 횟수:").grid(row=0, column=0, sticky=tk.W)
        self.block_count_var = tk.StringVar(value="0")
        ttk.Label(stats_frame, textvariable=self.block_count_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        # 우회 시도
        ttk.Label(stats_frame, text="우회 시도:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        self.bypass_attempts_var = tk.StringVar(value="0")
        ttk.Label(stats_frame, textvariable=self.bypass_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # 현재 난이도
        ttk.Label(stats_frame, text="현재 난이도:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        self.current_difficulty_var = tk.StringVar(value="1")
        ttk.Label(stats_frame, textvariable=self.current_difficulty_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # 보안 상태
        ttk.Label(stats_frame, text="보안 상태:").grid(row=3, column=0, sticky=tk.W, pady=(5, 0))
        self.security_status_var = tk.StringVar(value="보안 모니터링 활성화")
        ttk.Label(stats_frame, textvariable=self.security_status_var,
                 font=('Helvetica', 12, 'bold')).grid(row=3, column=1, padx=(10, 0), pady=(5, 0))

        # 빠른 액션
        action_frame = ttk.LabelFrame(dashboard_frame, text="🎯 빠른 액션", padding="10")
        action_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Button(action_frame, text="🚀 집중 모드 시작",
                  command=self.start_focus_mode).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(action_frame, text="⏹️ 집중 모드 중지",
                  command=self.stop_focus_mode).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(action_frame, text="🔒 즉시 차단",
                  command=self.block_now).grid(row=0, column=2, padx=(0, 10))
        ttk.Button(action_frame, text="🔓 즉시 해제",
                  command=self.unblock_now).grid(row=0, column=3)

    def create_timer_tab(self):
        """타이머 설정 탭"""
        timer_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(timer_frame, text="⏰ 타이머")

        # 시간 설정
        time_frame = ttk.LabelFrame(timer_frame, text="시간 설정", padding="10")
        time_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Label(time_frame, text="시작 시간:").grid(row=0, column=0, sticky=tk.W)
        self.start_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_start_time", "09:00"))
        ttk.Entry(time_frame, textvariable=self.start_time_var, width=10).grid(row=0, column=1, padx=(10, 0))

        ttk.Label(time_frame, text="종료 시간:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        self.end_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_end_time", "18:00"))
        ttk.Entry(time_frame, textvariable=self.end_time_var, width=10).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # 난이도 설정
        difficulty_frame = ttk.LabelFrame(timer_frame, text="알고리즘 문제 난이도", padding="10")
        difficulty_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.difficulty_var = tk.IntVar(value=config_manager.get("focus_mode.default_difficulty", 1))
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        for i in range(1, max_difficulty + 1):
            ttk.Radiobutton(difficulty_frame, text=f"난이도 {i}",
                           variable=self.difficulty_var, value=i).grid(row=0, column=i-1, padx=(0, 10))

    def create_browser_tab(self):
        """브라우저 관리 탭"""
        browser_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(browser_frame, text="🌐 브라우저")

        # 브라우저 상태
        status_frame = ttk.LabelFrame(browser_frame, text="📊 브라우저 상태", padding="10")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 실행 중인 브라우저 목록
        self.running_browsers_var = tk.StringVar(value="확인 중...")
        ttk.Label(status_frame, text="실행 중인 브라우저:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(status_frame, textvariable=self.running_browsers_var,
                 font=('Helvetica', 10, 'bold')).grid(row=0, column=1, padx=(10, 0), sticky=tk.W)

        # 브라우저 제어 버튼
        control_frame = ttk.LabelFrame(browser_frame, text="🎮 브라우저 제어", padding="10")
        control_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 첫 번째 행
        ttk.Button(control_frame, text="🔄 브라우저 재시작",
                  command=self.restart_browsers).grid(row=0, column=0, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🧹 캐시 초기화",
                  command=self.clear_browser_cache).grid(row=0, column=1, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🔄 새로고침",
                  command=self.refresh_browsers).grid(row=0, column=2, padx=(0, 10), pady=(0, 5))

        # 두 번째 행
        ttk.Button(control_frame, text="💾 세션 저장",
                  command=self.save_browser_sessions).grid(row=1, column=0, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="📂 세션 복구",
                  command=self.restore_browser_sessions).grid(row=1, column=1, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🚀 안전 재시작",
                  command=self.safe_browser_restart).grid(row=1, column=2, padx=(0, 10), pady=(0, 5))

        # 세 번째 행
        ttk.Button(control_frame, text="🌐 DNS 초기화",
                  command=self.flush_dns_cache).grid(row=2, column=0, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="⚡ 최적화 정리",
                  command=self.optimized_browser_clear).grid(row=2, column=1, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🔄 상태 새로고침",
                  command=self.refresh_browser_status).grid(row=2, column=2, padx=(0, 10), pady=(0, 5))

        # 네 번째 행 (집중 모드 연동)
        ttk.Button(control_frame, text="🎯 집중 모드 브라우저 제어",
                  command=self.focus_mode_browser_control).grid(row=3, column=0, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🔓 집중 모드 브라우저 해제",
                  command=self.release_focus_mode_browser).grid(row=3, column=1, padx=(0, 10), pady=(0, 5))
        ttk.Button(control_frame, text="🛡️ 강화된 차단 적용",
                  command=self.enhanced_browser_blocking).grid(row=3, column=2, padx=(0, 10), pady=(0, 5))

        # 고급 설정
        advanced_frame = ttk.LabelFrame(browser_frame, text="⚙️ 고급 설정", padding="10")
        advanced_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_session_save_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(advanced_frame, text="자동 세션 저장",
                       variable=self.auto_session_save_var).grid(row=0, column=0, sticky=tk.W)

        self.auto_cache_clear_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(advanced_frame, text="자동 캐시 초기화",
                       variable=self.auto_cache_clear_var).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

                # 브라우저 정보
        info_frame = ttk.LabelFrame(browser_frame, text="ℹ️ 브라우저 정보", padding="10")
        info_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.browser_info_var = tk.StringVar(value="로딩 중...")
        info_text = tk.Text(info_frame, height=6, width=60, wrap=tk.WORD)
        info_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # 스크롤바 추가
        scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=info_text.yview)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        info_text.configure(yscrollcommand=scrollbar.set)

        self.browser_info_text = info_text

        # 실시간 브라우저 제어 대시보드
        dashboard_frame = ttk.LabelFrame(browser_frame, text="📊 실시간 브라우저 대시보드", padding="10")
        dashboard_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 첫 번째 행 - 브라우저별 상태
        browser_status_frame = ttk.Frame(dashboard_frame)
        browser_status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # Chrome 상태
        chrome_frame = ttk.LabelFrame(browser_status_frame, text="Chrome", padding="5")
        chrome_frame.grid(row=0, column=0, padx=(0, 10))
        self.chrome_status_var = tk.StringVar(value="확인 중...")
        ttk.Label(chrome_frame, textvariable=self.chrome_status_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # Safari 상태
        safari_frame = ttk.LabelFrame(browser_status_frame, text="Safari", padding="5")
        safari_frame.grid(row=0, column=1, padx=(0, 10))
        self.safari_status_var = tk.StringVar(value="확인 중...")
        ttk.Label(safari_frame, textvariable=self.safari_status_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # Firefox 상태
        firefox_frame = ttk.LabelFrame(browser_status_frame, text="Firefox", padding="5")
        firefox_frame.grid(row=0, column=2, padx=(0, 10))
        self.firefox_status_var = tk.StringVar(value="확인 중...")
        ttk.Label(firefox_frame, textvariable=self.firefox_status_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # Whale 상태
        whale_frame = ttk.LabelFrame(browser_status_frame, text="Whale", padding="5")
        whale_frame.grid(row=0, column=3, padx=(0, 10))
        self.whale_status_var = tk.StringVar(value="확인 중...")
        ttk.Label(whale_frame, textvariable=self.whale_status_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # Edge 상태
        edge_frame = ttk.LabelFrame(browser_status_frame, text="Edge", padding="5")
        edge_frame.grid(row=0, column=4)
        self.edge_status_var = tk.StringVar(value="확인 중...")
        ttk.Label(edge_frame, textvariable=self.edge_status_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # 두 번째 행 - 실시간 통계
        stats_frame = ttk.Frame(dashboard_frame)
        stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 모니터링 상태
        monitoring_frame = ttk.LabelFrame(stats_frame, text="모니터링 상태", padding="5")
        monitoring_frame.grid(row=0, column=0, padx=(0, 10))
        self.monitoring_status_var = tk.StringVar(value="비활성화")
        ttk.Label(monitoring_frame, textvariable=self.monitoring_status_var, font=('Helvetica', 10, 'bold')).grid(row=0, column=0)

        # 차단된 브라우저 수
        blocked_frame = ttk.LabelFrame(stats_frame, text="차단된 브라우저", padding="5")
        blocked_frame.grid(row=0, column=1, padx=(0, 10))
        self.blocked_browsers_var = tk.StringVar(value="0개")
        ttk.Label(blocked_frame, textvariable=self.blocked_browsers_var, font=('Helvetica', 10, 'bold')).grid(row=0, column=0)

        # 마지막 업데이트
        update_frame = ttk.LabelFrame(stats_frame, text="마지막 업데이트", padding="5")
        update_frame.grid(row=0, column=2)
        self.last_update_var = tk.StringVar(value="없음")
        ttk.Label(update_frame, textvariable=self.last_update_var, font=('Helvetica', 9)).grid(row=0, column=0)

        # 고급 브라우저 설정 패널
        advanced_settings_frame = ttk.LabelFrame(browser_frame, text="⚙️ 고급 브라우저 설정", padding="10")
        advanced_settings_frame.grid(row=5, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 첫 번째 행 - 자동화 설정
        automation_frame = ttk.LabelFrame(advanced_settings_frame, text="🤖 자동화 설정", padding="10")
        automation_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_browser_monitoring_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(automation_frame, text="자동 브라우저 모니터링",
                       variable=self.auto_browser_monitoring_var).grid(row=0, column=0, sticky=tk.W)

        self.auto_cache_clear_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(automation_frame, text="자동 캐시 초기화",
                       variable=self.auto_cache_clear_var).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

        self.auto_session_save_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(automation_frame, text="자동 세션 저장",
                       variable=self.auto_session_save_var).grid(row=0, column=2, sticky=tk.W, padx=(20, 0))

        # 두 번째 행 - 차단 설정
        blocking_frame = ttk.LabelFrame(advanced_settings_frame, text="🚫 차단 설정", padding="10")
        blocking_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.enable_enhanced_blocking_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(blocking_frame, text="강화된 차단 활성화",
                       variable=self.enable_enhanced_blocking_var).grid(row=0, column=0, sticky=tk.W)

        self.enable_browser_extensions_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(blocking_frame, text="브라우저 확장 프로그램 사용",
                       variable=self.enable_browser_extensions_var).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

        self.enable_additional_rules_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(blocking_frame, text="추가 차단 규칙 적용",
                       variable=self.enable_additional_rules_var).grid(row=0, column=2, sticky=tk.W, padx=(20, 0))

        # 세 번째 행 - 성능 설정
        performance_frame = ttk.LabelFrame(advanced_settings_frame, text="⚡ 성능 설정", padding="10")
        performance_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.enable_dns_flush_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(performance_frame, text="DNS 캐시 자동 초기화",
                       variable=self.enable_dns_flush_var).grid(row=0, column=0, sticky=tk.W)

        self.enable_optimized_clear_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(performance_frame, text="최적화된 정리 사용",
                       variable=self.enable_optimized_clear_var).grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

        self.enable_force_refresh_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(performance_frame, text="강제 새로고침 사용",
                       variable=self.enable_force_refresh_var).grid(row=0, column=2, sticky=tk.W, padx=(20, 0))

        # 브라우저별 상세 설정
        browser_specific_frame = ttk.LabelFrame(browser_frame, text="🔧 브라우저별 상세 설정", padding="10")
        browser_specific_frame.grid(row=6, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # 브라우저 선택
        browser_select_frame = ttk.Frame(browser_specific_frame)
        browser_select_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Label(browser_select_frame, text="브라우저 선택:").grid(row=0, column=0, sticky=tk.W)
        self.selected_browser_var = tk.StringVar(value="Google Chrome")
        browser_combo = ttk.Combobox(browser_select_frame, textvariable=self.selected_browser_var,
                                    values=["Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"],
                                    state="readonly", width=15)
        browser_combo.grid(row=0, column=1, padx=(10, 0))
        browser_combo.bind('<<ComboboxSelected>>', self.on_browser_selected)

        # 브라우저별 설정 버튼들
        browser_buttons_frame = ttk.Frame(browser_specific_frame)
        browser_buttons_frame.grid(row=1, column=0, sticky=(tk.W, tk.E))

        ttk.Button(browser_buttons_frame, text="🔧 개별 설정",
                  command=self.configure_browser).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(browser_buttons_frame, text="📊 상세 정보",
                  command=self.show_browser_details).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(browser_buttons_frame, text="🧹 개별 정리",
                  command=self.clean_browser).grid(row=0, column=2, padx=(0, 10))
        ttk.Button(browser_buttons_frame, text="🔄 개별 재시작",
                  command=self.restart_browser).grid(row=0, column=3)

        # 설정 저장/불러오기 버튼
        settings_buttons_frame = ttk.Frame(browser_specific_frame)
        settings_buttons_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))

        ttk.Button(settings_buttons_frame, text="💾 설정 저장",
                  command=self.save_browser_settings).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(settings_buttons_frame, text="📂 설정 불러오기",
                  command=self.load_browser_settings).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(settings_buttons_frame, text="🔄 설정 초기화",
                  command=self.reset_browser_settings).grid(row=0, column=2)

    def create_settings_tab(self):
        """설정 탭"""
        settings_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(settings_frame, text="⚙️ 설정")

        # 설정 저장 상태 표시
        status_frame = ttk.Frame(settings_frame)
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.settings_status_var = tk.StringVar(value="설정이 저장되었습니다")
        ttk.Label(status_frame, textvariable=self.settings_status_var,
                 font=('Helvetica', 10, 'italic')).grid(row=0, column=0, sticky=tk.W)

        # 일반 설정
        general_frame = ttk.LabelFrame(settings_frame, text="일반 설정", padding="10")
        general_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_start_var = tk.BooleanVar(value=config_manager.get("general.auto_start", True))
        auto_start_cb = ttk.Checkbutton(general_frame, text="시스템 시작 시 자동 실행",
                       variable=self.auto_start_var, command=lambda: self.on_setting_changed("general.auto_start", self.auto_start_var))
        auto_start_cb.grid(row=0, column=0, sticky=tk.W)

        self.browser_restart_var = tk.BooleanVar(value=config_manager.get("focus_mode.auto_restart_browser", True))
        browser_restart_cb = ttk.Checkbutton(general_frame, text="집중 모드 시작 시 브라우저 재시작",
                       variable=self.browser_restart_var, command=lambda: self.on_setting_changed("focus_mode.auto_restart_browser", self.browser_restart_var))
        browser_restart_cb.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        # 보안 설정
        security_frame = ttk.LabelFrame(settings_frame, text="보안 설정", padding="10")
        security_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.file_monitoring_var = tk.BooleanVar(value=config_manager.get("security.enable_file_monitoring", True))
        file_monitoring_cb = ttk.Checkbutton(security_frame, text="파일 모니터링 활성화",
                       variable=self.file_monitoring_var, command=lambda: self.on_setting_changed("security.enable_file_monitoring", self.file_monitoring_var))
        file_monitoring_cb.grid(row=0, column=0, sticky=tk.W)

        self.auto_recovery_var = tk.BooleanVar(value=config_manager.get("security.enable_auto_recovery", True))
        auto_recovery_cb = ttk.Checkbutton(security_frame, text="자동 복구 활성화",
                       variable=self.auto_recovery_var, command=lambda: self.on_setting_changed("security.enable_auto_recovery", self.auto_recovery_var))
        auto_recovery_cb.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        self.lock_hosts_var = tk.BooleanVar(value=config_manager.get("security.lock_hosts_file", True))
        lock_hosts_cb = ttk.Checkbutton(security_frame, text="hosts 파일 잠금",
                       variable=self.lock_hosts_var, command=lambda: self.on_setting_changed("security.lock_hosts_file", self.lock_hosts_var))
        lock_hosts_cb.grid(row=2, column=0, sticky=tk.W, pady=(5, 0))

        self.firewall_rules_var = tk.BooleanVar(value=config_manager.get("security.enable_firewall_rules", False))
        firewall_rules_cb = ttk.Checkbutton(security_frame, text="방화벽 규칙 적용",
                       variable=self.firewall_rules_var, command=lambda: self.on_setting_changed("security.enable_firewall_rules", self.firewall_rules_var))
        firewall_rules_cb.grid(row=3, column=0, sticky=tk.W, pady=(5, 0))

        self.dns_flush_var = tk.BooleanVar(value=config_manager.get("security.enable_dns_cache_flush", True))
        dns_flush_cb = ttk.Checkbutton(security_frame, text="DNS 캐시 초기화",
                       variable=self.dns_flush_var, command=lambda: self.on_setting_changed("security.enable_dns_cache_flush", self.dns_flush_var))
        dns_flush_cb.grid(row=4, column=0, sticky=tk.W, pady=(5, 0))

        self.browser_cache_var = tk.BooleanVar(value=config_manager.get("security.enable_browser_cache_clear", True))
        browser_cache_cb = ttk.Checkbutton(security_frame, text="브라우저 캐시 초기화",
                       variable=self.browser_cache_var, command=lambda: self.on_setting_changed("security.enable_browser_cache_clear", self.browser_cache_var))
        browser_cache_cb.grid(row=5, column=0, sticky=tk.W, pady=(5, 0))

        # 브라우저 설정
        browser_settings_frame = ttk.LabelFrame(settings_frame, text="🌐 브라우저 설정", padding="10")
        browser_settings_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_browser_monitoring_var = tk.BooleanVar(value=config_manager.get("browser.auto_monitoring", True))
        auto_browser_monitoring_cb = ttk.Checkbutton(browser_settings_frame, text="자동 브라우저 모니터링",
                       variable=self.auto_browser_monitoring_var, command=lambda: self.on_setting_changed("browser.auto_monitoring", self.auto_browser_monitoring_var))
        auto_browser_monitoring_cb.grid(row=0, column=0, sticky=tk.W)

        self.auto_cache_clear_var = tk.BooleanVar(value=config_manager.get("browser.auto_cache_clear", True))
        auto_cache_clear_cb = ttk.Checkbutton(browser_settings_frame, text="자동 캐시 초기화",
                       variable=self.auto_cache_clear_var, command=lambda: self.on_setting_changed("browser.auto_cache_clear", self.auto_cache_clear_var))
        auto_cache_clear_cb.grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

        self.auto_session_save_var = tk.BooleanVar(value=config_manager.get("browser.auto_session_save", True))
        auto_session_save_cb = ttk.Checkbutton(browser_settings_frame, text="자동 세션 저장",
                       variable=self.auto_session_save_var, command=lambda: self.on_setting_changed("browser.auto_session_save", self.auto_session_save_var))
        auto_session_save_cb.grid(row=0, column=2, sticky=tk.W, padx=(20, 0))

        # 성능 설정
        performance_frame = ttk.LabelFrame(settings_frame, text="⚡ 성능 설정", padding="10")
        performance_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.enable_dns_flush_var = tk.BooleanVar(value=config_manager.get("performance.enable_dns_flush", True))
        enable_dns_flush_cb = ttk.Checkbutton(performance_frame, text="DNS 캐시 자동 초기화",
                       variable=self.enable_dns_flush_var, command=lambda: self.on_setting_changed("performance.enable_dns_flush", self.enable_dns_flush_var))
        enable_dns_flush_cb.grid(row=0, column=0, sticky=tk.W)

        self.enable_optimized_clear_var = tk.BooleanVar(value=config_manager.get("performance.enable_optimized_clear", True))
        enable_optimized_clear_cb = ttk.Checkbutton(performance_frame, text="최적화된 정리 사용",
                       variable=self.enable_optimized_clear_var, command=lambda: self.on_setting_changed("performance.enable_optimized_clear", self.enable_optimized_clear_var))
        enable_optimized_clear_cb.grid(row=0, column=1, sticky=tk.W, padx=(20, 0))

        self.enable_force_refresh_var = tk.BooleanVar(value=config_manager.get("performance.enable_force_refresh", True))
        enable_force_refresh_cb = ttk.Checkbutton(performance_frame, text="강제 새로고침 사용",
                       variable=self.enable_force_refresh_var, command=lambda: self.on_setting_changed("performance.enable_force_refresh", self.enable_force_refresh_var))
        enable_force_refresh_cb.grid(row=0, column=2, sticky=tk.W, padx=(20, 0))

        # 설정 관리 버튼
        settings_control_frame = ttk.Frame(settings_frame)
        settings_control_frame.grid(row=5, column=0, sticky=(tk.W, tk.E), pady=(10, 0))

        ttk.Button(settings_control_frame, text="💾 설정 저장",
                  command=self.save_all_settings).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(settings_control_frame, text="📂 설정 불러오기",
                  command=self.load_all_settings).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(settings_control_frame, text="🔄 설정 초기화",
                  command=self.reset_all_settings).grid(row=0, column=2, padx=(0, 10))
        ttk.Button(settings_control_frame, text="📋 설정 내보내기",
                  command=self.export_settings).grid(row=0, column=3, padx=(0, 10))

    # ----- 설정 관리 메서드들 -----
    def on_setting_changed(self, setting_key, variable):
        """설정 변경 시 호출되는 이벤트 핸들러"""
        try:
            # 설정값을 직접 JSON 파일에 저장하는 방식으로 변경
            self.save_setting_to_file(setting_key, variable.get())

            # 설정 상태 업데이트
            self.settings_status_var.set("설정이 변경되었습니다 - 자동 저장됨")

            # 3초 후 상태 메시지 복원
            self.root.after(3000, lambda: self.settings_status_var.set("설정이 저장되었습니다"))

            # 설정 변경에 따른 즉시 적용
            self.apply_setting_change(setting_key, variable.get())

            logger.log("INFO", f"설정 변경됨: {setting_key} = {variable.get()}")

        except Exception as e:
            logger.log("ERROR", f"설정 변경 실패: {setting_key} - {e}")
            self.settings_status_var.set("설정 변경 실패")

    def save_setting_to_file(self, setting_key, value):
        """설정을 JSON 파일에 직접 저장"""
        try:
            # 설정 파일 경로
            config_file = "config.json"
            if not os.path.exists(config_file):
                config_file = os.path.join(os.path.dirname(__file__), "config.json")

            # 기존 설정 로드
            config_data = {}
            if os.path.exists(config_file):
                try:
                    with open(config_file, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                except:
                    config_data = {}

            # 점 표기법으로 설정값 설정
            keys = setting_key.split('.')
            current = config_data

            # 중간 키들 생성
            for key in keys[:-1]:
                if key not in current:
                    current[key] = {}
                current = current[key]

            # 마지막 키에 값 설정
            current[keys[-1]] = value

            # 파일에 저장
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=2, ensure_ascii=False)

            logger.log("INFO", f"설정 저장됨: {setting_key} = {value}")

        except Exception as e:
            logger.log("ERROR", f"설정 파일 저장 실패: {e}")
            raise

    def apply_setting_change(self, setting_key, value):
        """설정 변경에 따른 즉시 적용"""
        try:
            if setting_key == "security.enable_file_monitoring":
                if value:
                    if hasattr(self, 'monitor'):
                        self.monitor.start_monitoring()
                else:
                    if hasattr(self, 'monitor'):
                        self.monitor.stop_monitoring()

            elif setting_key == "security.lock_hosts_file":
                if value and hasattr(self, 'monitor'):
                    self.monitor.system_protection.lock_hosts_file()
                elif not value and hasattr(self, 'monitor'):
                    self.monitor.system_protection.unlock_hosts_file()

            elif setting_key == "browser.auto_monitoring":
                # 브라우저 모니터링은 집중 모드에서 자동으로 처리되므로
                # 여기서는 설정만 저장하고 실제 적용은 집중 모드 시작/종료 시 처리
                logger.log("INFO", f"브라우저 자동 모니터링 설정: {value}")

            elif setting_key == "general.auto_start":
                # 시스템 시작 시 자동 실행 설정 (macOS LaunchAgent)
                self.setup_auto_start(value)

        except Exception as e:
            logger.log("ERROR", f"설정 적용 실패: {setting_key} - {e}")

    def setup_auto_start(self, enable):
        """시스템 시작 시 자동 실행 설정"""
        try:
            if enable:
                # LaunchAgent 생성
                launch_agent_dir = os.path.expanduser("~/Library/LaunchAgents")
                os.makedirs(launch_agent_dir, exist_ok=True)

                launch_agent_plist = os.path.join(launch_agent_dir, "com.focustimer.plist")
                plist_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.focustimer</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/python3</string>
        <string>{os.path.abspath(__file__)}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
</dict>
</plist>"""

                with open(launch_agent_plist, 'w') as f:
                    f.write(plist_content)

                # LaunchAgent 로드
                os.system(f"launchctl load {launch_agent_plist}")
                logger.log("INFO", "자동 실행 설정이 활성화되었습니다")

            else:
                # LaunchAgent 제거
                launch_agent_plist = os.path.expanduser("~/Library/LaunchAgents/com.focustimer.plist")
                if os.path.exists(launch_agent_plist):
                    os.system(f"launchctl unload {launch_agent_plist}")
                    os.remove(launch_agent_plist)
                    logger.log("INFO", "자동 실행 설정이 비활성화되었습니다")

        except Exception as e:
            logger.log("ERROR", f"자동 실행 설정 실패: {e}")

    def save_all_settings(self):
        """모든 설정을 저장"""
        try:
            # 현재 GUI 상태의 모든 설정을 저장
            settings_to_save = {
                "general.auto_start": self.auto_start_var.get(),
                "focus_mode.auto_restart_browser": self.browser_restart_var.get(),
                "security.enable_file_monitoring": self.file_monitoring_var.get(),
                "security.enable_auto_recovery": self.auto_recovery_var.get(),
                "security.lock_hosts_file": self.lock_hosts_var.get(),
                "security.enable_firewall_rules": self.firewall_rules_var.get(),
                "security.enable_dns_cache_flush": self.dns_flush_var.get(),
                "security.enable_browser_cache_clear": self.browser_cache_var.get(),
                "browser.auto_monitoring": self.auto_browser_monitoring_var.get(),
                "browser.auto_cache_clear": self.auto_cache_clear_var.get(),
                "browser.auto_session_save": self.auto_session_save_var.get(),
                "performance.enable_dns_flush": self.enable_dns_flush_var.get(),
                "performance.enable_optimized_clear": self.enable_optimized_clear_var.get(),
                "performance.enable_force_refresh": self.enable_force_refresh_var.get()
            }

            # 직접 파일에 저장
            for key, value in settings_to_save.items():
                self.save_setting_to_file(key, value)

            self.settings_status_var.set("모든 설정이 저장되었습니다")
            logger.log("INFO", "모든 설정이 저장되었습니다")

        except Exception as e:
            logger.log("ERROR", f"설정 저장 실패: {e}")
            self.settings_status_var.set("설정 저장 실패")

    def load_all_settings(self):
        """모든 설정을 불러오기"""
        try:
            # 설정 파일에서 직접 불러오기
            config_data = self.load_settings_from_file()

            # GUI 업데이트
            self.auto_start_var.set(config_data.get("general", {}).get("auto_start", True))
            self.browser_restart_var.set(config_data.get("focus_mode", {}).get("auto_restart_browser", True))
            self.file_monitoring_var.set(config_data.get("security", {}).get("enable_file_monitoring", True))
            self.auto_recovery_var.set(config_data.get("security", {}).get("enable_auto_recovery", True))
            self.lock_hosts_var.set(config_data.get("security", {}).get("lock_hosts_file", True))
            self.firewall_rules_var.set(config_data.get("security", {}).get("enable_firewall_rules", False))
            self.dns_flush_var.set(config_data.get("security", {}).get("enable_dns_cache_flush", True))
            self.browser_cache_var.set(config_data.get("security", {}).get("enable_browser_cache_clear", True))
            self.auto_browser_monitoring_var.set(config_data.get("browser", {}).get("auto_monitoring", True))
            self.auto_cache_clear_var.set(config_data.get("browser", {}).get("auto_cache_clear", True))
            self.auto_session_save_var.set(config_data.get("browser", {}).get("auto_session_save", True))
            self.enable_dns_flush_var.set(config_data.get("performance", {}).get("enable_dns_flush", True))
            self.enable_optimized_clear_var.set(config_data.get("performance", {}).get("enable_optimized_clear", True))
            self.enable_force_refresh_var.set(config_data.get("performance", {}).get("enable_force_refresh", True))

            self.settings_status_var.set("설정이 불러와졌습니다")
            logger.log("INFO", "모든 설정이 불러와졌습니다")

        except Exception as e:
            logger.log("ERROR", f"설정 불러오기 실패: {e}")
            self.settings_status_var.set("설정 불러오기 실패")

    def load_settings_from_file(self):
        """설정 파일에서 설정 불러오기"""
        try:
            # 설정 파일 경로
            config_file = "config.json"
            if not os.path.exists(config_file):
                config_file = os.path.join(os.path.dirname(__file__), "config.json")

            # 설정 파일 로드
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                return {}

        except Exception as e:
            logger.log("ERROR", f"설정 파일 로드 실패: {e}")
            return {}

    def reset_all_settings(self):
        """모든 설정을 기본값으로 초기화"""
        if messagebox.askyesno("확인", "모든 설정을 기본값으로 초기화하시겠습니까?"):
            try:
                # 기본값으로 설정
                default_settings = {
                    "general.auto_start": True,
                    "focus_mode.auto_restart_browser": True,
                    "security.enable_file_monitoring": True,
                    "security.enable_auto_recovery": True,
                    "security.lock_hosts_file": True,
                    "security.enable_firewall_rules": False,
                    "security.enable_dns_cache_flush": True,
                    "security.enable_browser_cache_clear": True,
                    "browser.auto_monitoring": True,
                    "browser.auto_cache_clear": True,
                    "browser.auto_session_save": True,
                    "performance.enable_dns_flush": True,
                    "performance.enable_optimized_clear": True,
                    "performance.enable_force_refresh": True
                }

                # GUI 업데이트
                self.auto_start_var.set(default_settings["general.auto_start"])
                self.browser_restart_var.set(default_settings["focus_mode.auto_restart_browser"])
                self.file_monitoring_var.set(default_settings["security.enable_file_monitoring"])
                self.auto_recovery_var.set(default_settings["security.enable_auto_recovery"])
                self.lock_hosts_var.set(default_settings["security.lock_hosts_file"])
                self.firewall_rules_var.set(default_settings["security.enable_firewall_rules"])
                self.dns_flush_var.set(default_settings["security.enable_dns_cache_flush"])
                self.browser_cache_var.set(default_settings["security.enable_browser_cache_clear"])
                self.auto_browser_monitoring_var.set(default_settings["browser.auto_monitoring"])
                self.auto_cache_clear_var.set(default_settings["browser.auto_cache_clear"])
                self.auto_session_save_var.set(default_settings["browser.auto_session_save"])
                self.enable_dns_flush_var.set(default_settings["performance.enable_dns_flush"])
                self.enable_optimized_clear_var.set(default_settings["performance.enable_optimized_clear"])
                self.enable_force_refresh_var.set(default_settings["performance.enable_force_refresh"])

                                # 직접 파일에 저장
                for key, value in default_settings.items():
                    self.save_setting_to_file(key, value)

                self.settings_status_var.set("설정이 기본값으로 초기화되었습니다")
                logger.log("INFO", "모든 설정이 기본값으로 초기화되었습니다")

            except Exception as e:
                logger.log("ERROR", f"설정 초기화 실패: {e}")
                self.settings_status_var.set("설정 초기화 실패")

    def export_settings(self):
        """설정을 파일로 내보내기"""
        try:
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="설정 내보내기"
            )

            if filename:
                # 현재 설정 수집
                current_settings = {
                    "general.auto_start": self.auto_start_var.get(),
                    "focus_mode.auto_restart_browser": self.browser_restart_var.get(),
                    "security.enable_file_monitoring": self.file_monitoring_var.get(),
                    "security.enable_auto_recovery": self.auto_recovery_var.get(),
                    "security.lock_hosts_file": self.lock_hosts_var.get(),
                    "security.enable_firewall_rules": self.firewall_rules_var.get(),
                    "security.enable_dns_cache_flush": self.dns_flush_var.get(),
                    "security.enable_browser_cache_clear": self.browser_cache_var.get(),
                    "browser.auto_monitoring": self.auto_browser_monitoring_var.get(),
                    "browser.auto_cache_clear": self.auto_cache_clear_var.get(),
                    "browser.auto_session_save": self.auto_session_save_var.get(),
                    "performance.enable_dns_flush": self.enable_dns_flush_var.get(),
                    "performance.enable_optimized_clear": self.enable_optimized_clear_var.get(),
                    "performance.enable_force_refresh": self.enable_force_refresh_var.get()
                }

                # JSON 파일로 저장
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(current_settings, f, indent=2, ensure_ascii=False)

                self.settings_status_var.set(f"설정이 내보내졌습니다: {os.path.basename(filename)}")
                logger.log("INFO", f"설정이 내보내졌습니다: {filename}")

        except Exception as e:
            logger.log("ERROR", f"설정 내보내기 실패: {e}")
            self.settings_status_var.set("설정 내보내기 실패")

    def create_stats_tab(self):
        """통계 탭"""
        stats_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(stats_frame, text="📈 통계")

        # 기본 통계
        basic_stats_frame = ttk.LabelFrame(stats_frame, text="📊 기본 통계", padding="10")
        basic_stats_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.total_focus_time_var = tk.StringVar(value="0시간")
        ttk.Label(basic_stats_frame, text="총 집중 시간:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(basic_stats_frame, textvariable=self.total_focus_time_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        self.block_count_var = tk.StringVar(value="0회")
        ttk.Label(basic_stats_frame, text="차단 횟수:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(basic_stats_frame, textvariable=self.block_count_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        self.bypass_attempts_var = tk.StringVar(value="0회")
        ttk.Label(basic_stats_frame, text="우회 시도:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(basic_stats_frame, textvariable=self.bypass_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # 보안 통계
        security_stats_frame = ttk.LabelFrame(stats_frame, text="🛡️ 보안 통계", padding="10")
        security_stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.current_difficulty_var = tk.StringVar(value="1")
        ttk.Label(security_stats_frame, text="현재 난이도:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(security_stats_frame, textvariable=self.current_difficulty_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        self.security_status_var = tk.StringVar(value="보안 모니터링 활성화")
        ttk.Label(security_stats_frame, text="보안 상태:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(security_stats_frame, textvariable=self.security_status_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        self.failed_attempts_var = tk.StringVar(value="0회")
        ttk.Label(security_stats_frame, text="실패한 시도:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(security_stats_frame, textvariable=self.failed_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # 시스템 통계
        system_stats_frame = ttk.LabelFrame(stats_frame, text="⚙️ 시스템 통계", padding="10")
        system_stats_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.last_check_var = tk.StringVar(value="없음")
        ttk.Label(system_stats_frame, text="마지막 체크:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(system_stats_frame, textvariable=self.last_check_var,
                 font=('Helvetica', 10)).grid(row=0, column=1, padx=(10, 0))

        self.monitoring_status_var = tk.StringVar(value="활성화")
        ttk.Label(system_stats_frame, text="모니터링 상태:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(system_stats_frame, textvariable=self.monitoring_status_var,
                 font=('Helvetica', 10)).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # 통계 제어
        control_frame = ttk.Frame(stats_frame)
        control_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(10, 0))

        ttk.Button(control_frame, text="🔄 통계 새로고침",
                  command=self.refresh_stats).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(control_frame, text="📊 통계 내보내기",
                  command=self.export_stats).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(control_frame, text="🗑️ 통계 초기화",
                  command=self.reset_stats).grid(row=0, column=2)

    def create_logs_tab(self):
        """로그 뷰어 탭"""
        logs_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(logs_frame, text="📝 시스템 로그")

        # 로그 제어
        control_frame = ttk.Frame(logs_frame)
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Button(control_frame, text="🔄 새로고침",
                  command=self.refresh_logs).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(control_frame, text="🗑️ 로그 지우기",
                  command=self.clear_logs).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(control_frame, text="💾 로그 저장",
                  command=self.save_logs).grid(row=0, column=2)

        # 로그 표시
        log_frame = ttk.LabelFrame(logs_frame, text="실시간 로그", padding="10")
        log_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))

        # 로그 텍스트 위젯
        self.log_text = tk.Text(log_frame, height=15, width=80, font=('Courier', 9))
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=log_scrollbar.set)

        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        log_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

        # 로그 프레임 그리드 가중치
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        logs_frame.columnconfigure(0, weight=1)
        logs_frame.rowconfigure(1, weight=1)

    def refresh_logs(self):
        """로그 새로고침 (A코드 방식 - 최근 50줄 표시)"""
        try:
            log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
            if os.path.exists(log_path):
                with open(log_path, 'r', encoding='utf-8') as f:
                    logs = f.readlines()[-50:]  # 최근 50줄 (A코드 방식)

                self.log_text.delete(1.0, tk.END)
                for log in logs:
                    self.log_text.insert(tk.END, log)

                self.log_text.see(tk.END)
            else:
                self.log_text.delete(1.0, tk.END)
                self.log_text.insert(tk.END, "로그 파일이 아직 생성되지 않았습니다.\n")
        except Exception as e:
            self.log_text.delete(1.0, tk.END)
            self.log_text.insert(tk.END, f"로그 읽기 실패: {e}\n")

    def clear_logs(self):
        """로그 지우기"""
        if messagebox.askyesno("확인", "로그를 지우시겠습니까?"):
            try:
                log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
                if os.path.exists(log_path):
                    with open(log_path, 'w') as f:
                        f.write("")
                    self.refresh_logs()
                    messagebox.showinfo("성공", "로그가 지워졌습니다.")
            except Exception as e:
                messagebox.showerror("오류", f"로그 지우기 실패: {e}")

    def save_logs(self):
        """로그 저장"""
        try:
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".log",
                filetypes=[("Log files", "*.log"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
                if os.path.exists(log_path):
                    import shutil
                    shutil.copy2(log_path, filename)
                    messagebox.showinfo("성공", f"로그가 저장되었습니다: {filename}")
                else:
                    messagebox.showwarning("경고", "로그 파일이 없습니다.")
        except Exception as e:
            messagebox.showerror("오류", f"로그 저장 실패: {e}")

    def refresh_stats(self):
        """통계 새로고침"""
        try:
            self.update_stats()
            messagebox.showinfo("성공", "통계가 새로고침되었습니다.")
        except Exception as e:
            messagebox.showerror("오류", f"통계 새로고침 실패: {e}")

    def export_stats(self):
        """통계 내보내기"""
        try:
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                stats_data = {
                    "timestamp": datetime.datetime.now().isoformat(),
                    "basic_stats": {
                        "total_focus_time": self.total_focus_time_var.get(),
                        "block_count": self.block_count_var.get(),
                        "bypass_attempts": self.bypass_attempts_var.get()
                    },
                    "security_stats": {
                        "current_difficulty": self.current_difficulty_var.get(),
                        "security_status": self.security_status_var.get(),
                        "failed_attempts": self.failed_attempts_var.get()
                    },
                    "system_stats": {
                        "last_check": self.last_check_var.get(),
                        "monitoring_status": self.monitoring_status_var.get()
                    }
                }

                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(stats_data, f, indent=2, ensure_ascii=False)

                messagebox.showinfo("성공", f"통계가 내보내졌습니다: {filename}")
        except Exception as e:
            messagebox.showerror("오류", f"통계 내보내기 실패: {e}")

    def reset_stats(self):
        """통계 초기화"""
        if messagebox.askyesno("확인", "모든 통계를 초기화하시겠습니까?"):
            try:
                # 상태 초기화
                state.block_count = 0
                state.bypass_attempts = 0
                if challenge:
                    challenge.failed_attempts = 0

                # GUI 업데이트
                self.update_stats()

                # 상태 저장
                save_state()

                messagebox.showinfo("성공", "통계가 초기화되었습니다.")
            except Exception as e:
                messagebox.showerror("오류", f"통계 초기화 실패: {e}")

    def start_focus_mode(self):
        """집중 모드 시작 (브라우저 제어 연동)"""
        try:
            # 시간 파싱
            start_time = self.start_time_var.get()
            end_time = self.end_time_var.get()

            start_hour, start_minute = map(int, start_time.split(':'))
            end_hour, end_minute = map(int, end_time.split(':'))

            # 상태 설정
            now = datetime.datetime.now()
            state.focus_start_time = now.replace(hour=start_hour, minute=start_minute, second=0, microsecond=0)
            state.focus_end_time = now.replace(hour=end_hour, minute=end_minute, second=0, microsecond=0)
            state.is_focus_mode = True

            if challenge:
                challenge.difficulty_level = self.difficulty_var.get()

            save_state()

            # 브라우저 강화 제어 시작
            if hasattr(self, 'browser_manager'):
                self.browser_manager.focus_mode_browser_control(enable_focus=True)
                logger.log("INFO", "집중 모드: 브라우저 강화 제어 시작됨")

            # 모니터링 시작
            if not self.running:
                self.start_monitoring()

            self.status_label.config(text="집중 모드 활성화 (브라우저 제어)")
            self.status_var.set("집중 모드 시작됨 - 브라우저 제어 활성화")
            messagebox.showinfo("성공", "집중 모드가 시작되었습니다!\n브라우저 강화 제어가 활성화되었습니다.")

        except Exception as e:
            messagebox.showerror("오류", f"집중 모드 시작 실패: {e}")

    def stop_focus_mode(self):
        """집중 모드 중지 (강화된 제한)"""
        try:
            # 강화된 집중모드 제한 체크
            if state.is_focus_mode:
                # 경고 사운드 재생
                self.play_warning_sound()

                # 강력한 경고 메시지
                message = f"🚫 집중모드 제한!\n\n집중 모드 중지는 집중모드가 활성화된 상태에서 절대 허용되지 않습니다.\n\n집중모드를 완전히 종료하려면 집중모드 설정에서 비활성화하거나\n집중모드 시간이 끝날 때까지 기다려주세요."
                messagebox.showwarning("집중모드 제한", message)

                # 차단 사운드 재생
                self.play_block_sound()

                logger.log("WARNING", "집중모드 활성화 상태에서 중지 시도 차단")
                return

            state.is_focus_mode = False
            state.is_blocked = False

            # 브라우저 제어 복구
            if hasattr(self, 'browser_manager'):
                self.browser_manager.focus_mode_browser_control(enable_focus=False)
                logger.log("INFO", "집중 모드: 브라우저 제어 복구 완료")

            # 차단 해제
            unblock_websites()

            save_state()

            self.status_label.config(text="집중 모드 비활성화")
            self.status_var.set("집중 모드 중지됨 - 브라우저 제어 해제")
            messagebox.showinfo("성공", "집중 모드가 중지되었습니다!\n브라우저 제어가 해제되었습니다.")

        except Exception as e:
            messagebox.showerror("오류", f"집중 모드 중지 실패: {e}")

    def block_now(self):
        """즉시 차단"""
        try:
            block_websites()
            messagebox.showinfo("알림", "웹사이트가 즉시 차단되었습니다!")
        except Exception as e:
            messagebox.showerror("오류", f"즉시 차단 실패: {e}")

    def unblock_now(self):
        """즉시 해제 (강화된 제한)"""
        try:
            # 강화된 집중모드 제한 체크
            if state.is_focus_mode:
                # 경고 사운드 재생
                self.play_warning_sound()

                # 강력한 경고 메시지
                message = f"🚫 집중모드 제한!\n\n즉시 해제는 집중모드가 활성화된 상태에서 절대 허용되지 않습니다.\n\n집중모드가 완전히 종료될 때까지 기다려주세요."
                messagebox.showwarning("집중모드 제한", message)

                # 차단 사운드 재생
                self.play_block_sound()

                logger.log("WARNING", "집중모드 활성화 상태에서 즉시 해제 시도 차단")
                return

            unblock_websites()
            messagebox.showinfo("알림", "웹사이트 차단이 해제되었습니다!")
        except Exception as e:
            messagebox.showerror("오류", f"즉시 해제 실패: {e}")

    def start_monitoring(self):
        """모니터링 시작"""
        if not self.running:
            self.running = True
            self.monitor.start_monitoring()

            # 모니터링 스레드 시작
            self.monitor_thread = threading.Thread(target=self.monitoring_loop, daemon=True)
            self.monitor_thread.start()

    def monitoring_loop(self):
        """모니터링 루프"""
        while self.running:
            try:
                self.check_focus_time()
                time.sleep(60)  # 1분마다 체크
            except Exception as e:
                logger.log("ERROR", f"모니터링 루프 오류: {e}")

    def check_focus_time(self):
        """집중 시간 체크"""
        if not state.is_focus_mode:
            return

        now = datetime.datetime.now()
        current_time = now.time()

        if state.focus_start_time and state.focus_end_time:
            start_time = state.focus_start_time.time()
            end_time = state.focus_end_time.time()

            # 시간대 비교
            if start_time <= end_time:
                should_be_blocked = start_time <= current_time <= end_time
            else:
                should_be_blocked = current_time >= start_time or current_time <= end_time

            # 상태 변경 처리
            if state.is_blocked != should_be_blocked:
                if should_be_blocked:
                    block_websites()
                    self.monitor.system_protection.lock_hosts_file()
                    logger.log("INFO", "집중 모드 시작 - 차단 적용")
                else:
                    unblock_websites()
                    self.monitor.system_protection.unlock_hosts_file()
                    logger.log("INFO", "집중 모드 종료 - 차단 해제")

                state.is_blocked = should_be_blocked
                save_state()

    def update_stats(self):
        """통계 업데이트"""
        try:
            # 기본 통계
            self.block_count_var.set(f"{state.block_count}회")
            self.bypass_attempts_var.set(f"{state.bypass_attempts}회")
            self.current_difficulty_var.set(str(challenge.difficulty_level if challenge else 1))

            # 보안 상태
            if self.monitor.monitoring:
                self.security_status_var.set("보안 모니터링 활성화")
            else:
                self.security_status_var.set("보안 모니터링 비활성화")

            # 시간 표시
            if state.focus_start_time and state.focus_end_time:
                start_str = state.focus_start_time.strftime("%H:%M")
                end_str = state.focus_end_time.strftime("%H:%M")
                self.time_var.set(f"설정 시간: {start_str} ~ {end_str}")
            else:
                self.time_var.set("")

            # 상태 표시
            if state.is_focus_mode:
                if state.is_blocked:
                    self.status_label.config(text="집중 모드 활성화 (차단 중)")
                else:
                    self.status_label.config(text="집중 모드 활성화 (대기 중)")
            else:
                self.status_label.config(text="집중 모드 비활성화")

            # 추가 통계 업데이트
            self.failed_attempts_var.set(f"{challenge.failed_attempts if challenge else 0}회")

            # 마지막 체크 시간
            if state.last_check:
                self.last_check_var.set(state.last_check.strftime("%Y-%m-%d %H:%M:%S"))
            else:
                self.last_check_var.set("없음")

            # 모니터링 상태
            if self.monitor.monitoring:
                self.monitoring_status_var.set("활성화")
            else:
                self.monitoring_status_var.set("비활성화")

            # 로그 업데이트 (로그 탭이 활성화된 경우)
            try:
                current_tab = self.notebook.select()
                if "로그" in self.notebook.tab(current_tab, "text"):
                    self.refresh_logs()
            except:
                pass

            # 브라우저 상태 업데이트 (브라우저 탭이 활성화된 경우)
            try:
                current_tab = self.notebook.select()
                if "브라우저" in self.notebook.tab(current_tab, "text"):
                    self.refresh_browser_status()
                    self.update_browser_dashboard()  # 브라우저 대시보드 업데이트 추가
            except:
                pass

        except Exception as e:
            logger.log("ERROR", f"통계 업데이트 실패: {e}")

    def export_config(self):
        """설정 내보내기"""
        messagebox.showinfo("알림", "설정 내보내기 기능")

    def import_config(self):
        """설정 가져오기"""
        messagebox.showinfo("알림", "설정 가져오기 기능")

    def open_cli(self):
        """CLI 모드 열기"""
        cli_path = APP_ROOT / "MacOS" / "FocusTimerCLI"
        if cli_path.exists():
            try:
                subprocess.Popen([str(PYTHON_PATH), str(cli_path)])
            except Exception as e:
                messagebox.showerror("오류", f"CLI 모드 실행 실패: {e}")
        else:
            messagebox.showerror("오류", f"CLI 파일을 찾을 수 없습니다: {cli_path}")

    def open_web(self):
        """웹 인터페이스 열기"""
        messagebox.showinfo("알림", "웹 인터페이스가 브라우저에서 열립니다!")

    def view_logs(self):
        """로그 보기"""
        log_path = LOG_PATH
        if os.path.exists(log_path):
            try:
                subprocess.run(["open", "-a", "Console", log_path])
            except Exception as e:
                messagebox.showerror("오류", f"로그 파일 열기 실패: {e}")
        else:
            messagebox.showinfo("알림", "로그 파일이 아직 생성되지 않았습니다.")

    def show_help(self):
        """도움말 보기"""
        messagebox.showinfo("도움말", "FocusTimer 사용법을 확인하세요!")

    def show_about(self):
        """정보 보기"""
        messagebox.showinfo("정보", f"{PRODUCT_NAME} v{VERSION}\n집중 모드 시스템")

    # ----- 브라우저 관리 메서드들 -----
    def refresh_browsers(self):
        """브라우저 새로고침"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.force_browser_refresh()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def save_browser_sessions(self):
        """브라우저 세션 저장"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.save_browser_sessions()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def restore_browser_sessions(self):
        """브라우저 세션 복구"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.restore_browser_sessions()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def safe_browser_restart(self):
        """안전한 브라우저 재시작"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.force_browser_restart()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def flush_dns_cache(self):
        """DNS 캐시 초기화"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.simple_dns_flush()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def optimized_browser_clear(self):
        """최적화된 브라우저 정리"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.optimized_browser_clear()
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def refresh_browser_status(self):
        """브라우저 상태 새로고침"""
        if hasattr(self, 'browser_manager'):
            status = self.browser_manager.get_browser_status()
            running_browsers = status.get("running_browsers", [])

            if running_browsers:
                self.running_browsers_var.set(", ".join(running_browsers))
            else:
                self.running_browsers_var.set("실행 중인 브라우저 없음")

            # 브라우저 정보 업데이트
            info_text = f"지원 브라우저: {', '.join(status.get('supported_browsers', []))}\n"
            info_text += f"실행 중인 브라우저: {len(running_browsers)}개\n"
            info_text += f"마지막 업데이트: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

            if running_browsers:
                info_text += "실행 중인 브라우저 목록:\n"
                for browser in running_browsers:
                    info_text += f"• {browser}\n"
            else:
                info_text += "현재 실행 중인 브라우저가 없습니다."

            self.browser_info_text.delete(1.0, tk.END)
            self.browser_info_text.insert(tk.END, info_text)
        else:
            logger.log("ERROR", "BrowserManager가 초기화되지 않았습니다.")

    def focus_mode_browser_control(self):
        """집중 모드 브라우저 제어 (GUI 버튼용)"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.focus_mode_browser_control(enable_focus=True)
            messagebox.showinfo("성공", "집중 모드 브라우저 제어가 활성화되었습니다!")
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def release_focus_mode_browser(self):
        """집중 모드 브라우저 제어 해제 (GUI 버튼용)"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.focus_mode_browser_control(enable_focus=False)
            messagebox.showinfo("성공", "집중 모드 브라우저 제어가 해제되었습니다!")
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def enhanced_browser_blocking(self):
        """강화된 브라우저 차단 적용 (GUI 버튼용)"""
        if hasattr(self, 'browser_manager'):
            self.browser_manager.enhance_browser_blocking()
            messagebox.showinfo("성공", "강화된 브라우저 차단이 적용되었습니다!")
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    # ----- 고급 브라우저 관리 GUI 메서드들 -----
    def on_browser_selected(self, event=None):
        """브라우저 선택 시 호출되는 메서드"""
        selected_browser = self.selected_browser_var.get()
        logger.log("INFO", f"선택된 브라우저: {selected_browser}")

    def configure_browser(self):
        """선택된 브라우저 개별 설정"""
        selected_browser = self.selected_browser_var.get()
        if hasattr(self, 'browser_manager'):
            # 브라우저별 설정 창 표시
            self.show_browser_config_dialog(selected_browser)
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def show_browser_config_dialog(self, browser):
        """브라우저 설정 다이얼로그 표시"""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"{browser} 설정")
        dialog.geometry("400x300")
        dialog.transient(self.root)
        dialog.grab_set()

        # 설정 옵션들
        ttk.Label(dialog, text=f"{browser} 고급 설정", font=('Helvetica', 14, 'bold')).pack(pady=10)

        # 캐시 설정
        cache_frame = ttk.LabelFrame(dialog, text="캐시 설정", padding="10")
        cache_frame.pack(fill=tk.X, padx=10, pady=5)

        clear_cache_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(cache_frame, text="캐시 자동 정리",
                       variable=clear_cache_var).pack(anchor=tk.W)

        clear_history_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(cache_frame, text="히스토리 정리",
                       variable=clear_history_var).pack(anchor=tk.W)

        # 성능 설정
        perf_frame = ttk.LabelFrame(dialog, text="성능 설정", padding="10")
        perf_frame.pack(fill=tk.X, padx=10, pady=5)

        force_refresh_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(perf_frame, text="강제 새로고침",
                       variable=force_refresh_var).pack(anchor=tk.W)

        dns_flush_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(perf_frame, text="DNS 캐시 초기화",
                       variable=dns_flush_var).pack(anchor=tk.W)

        # 적용 버튼
        ttk.Button(dialog, text="적용",
                  command=lambda: self.apply_browser_config(browser, {
                      'clear_cache': clear_cache_var.get(),
                      'clear_history': clear_history_var.get(),
                      'force_refresh': force_refresh_var.get(),
                      'dns_flush': dns_flush_var.get()
                  })).pack(pady=10)

    def apply_browser_config(self, browser, config):
        """브라우저 설정 적용"""
        try:
            if hasattr(self, 'browser_manager'):
                # 설정 적용 로직
                if config.get('clear_cache'):
                    self.browser_manager.clear_browser_cache()
                if config.get('dns_flush'):
                    self.browser_manager.simple_dns_flush()

                messagebox.showinfo("성공", f"{browser} 설정이 적용되었습니다!")
            else:
                messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")
        except Exception as e:
            messagebox.showerror("오류", f"설정 적용 실패: {e}")

    def show_browser_details(self):
        """선택된 브라우저 상세 정보 표시"""
        selected_browser = self.selected_browser_var.get()
        if hasattr(self, 'browser_manager'):
            status = self.browser_manager.get_browser_status()
            running_browsers = status.get("running_browsers", [])

            is_running = selected_browser in running_browsers

            details = f"브라우저: {selected_browser}\n"
            details += f"상태: {'실행 중' if is_running else '중지됨'}\n"
            details += f"지원 여부: {'지원됨' if selected_browser in status.get('supported_browsers', []) else '지원되지 않음'}\n"
            details += f"캐시 경로: {len(self.browser_manager.cache_paths.get(selected_browser, []))}개\n"
            details += f"마지막 업데이트: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

            messagebox.showinfo(f"{selected_browser} 상세 정보", details)
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def clean_browser(self):
        """선택된 브라우저 개별 정리"""
        selected_browser = self.selected_browser_var.get()
        if hasattr(self, 'browser_manager'):
            try:
                # 선택된 브라우저만 정리
                if selected_browser in self.browser_manager.cache_paths:
                    for path in self.browser_manager.cache_paths[selected_browser]:
                        expanded_path = os.path.expanduser(path)
                        if os.path.exists(expanded_path):
                            subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

                messagebox.showinfo("성공", f"{selected_browser} 정리가 완료되었습니다!")
            except Exception as e:
                messagebox.showerror("오류", f"{selected_browser} 정리 실패: {e}")
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def restart_browser(self):
        """선택된 브라우저 개별 재시작"""
        selected_browser = self.selected_browser_var.get()
        if hasattr(self, 'browser_manager'):
            try:
                # 선택된 브라우저만 재시작
                subprocess.run(["osascript", "-e", f'quit app "{selected_browser}"'], capture_output=True)
                time.sleep(2)
                subprocess.run(["open", "-a", selected_browser], capture_output=True)

                messagebox.showinfo("성공", f"{selected_browser} 재시작이 완료되었습니다!")
            except Exception as e:
                messagebox.showerror("오류", f"{selected_browser} 재시작 실패: {e}")
        else:
            messagebox.showerror("오류", "BrowserManager가 초기화되지 않았습니다.")

    def update_browser_dashboard(self):
        """브라우저 대시보드 업데이트"""
        if hasattr(self, 'browser_manager'):
            try:
                status = self.browser_manager.get_browser_status()
                running_browsers = status.get("running_browsers", [])

                # 브라우저별 상태 업데이트
                self.chrome_status_var.set("실행 중" if "Google Chrome" in running_browsers else "중지됨")
                self.safari_status_var.set("실행 중" if "Safari" in running_browsers else "중지됨")
                self.firefox_status_var.set("실행 중" if "Firefox" in running_browsers else "중지됨")
                self.whale_status_var.set("실행 중" if "Whale" in running_browsers else "중지됨")
                self.edge_status_var.set("실행 중" if "Microsoft Edge" in running_browsers else "중지됨")

                # 모니터링 상태 업데이트
                if hasattr(self.browser_manager, 'browser_monitoring_active'):
                    self.monitoring_status_var.set("활성화" if self.browser_manager.browser_monitoring_active else "비활성화")
                else:
                    self.monitoring_status_var.set("비활성화")

                # 차단된 브라우저 수 (집중 모드일 때)
                if state.is_focus_mode:
                    self.blocked_browsers_var.set(f"{len(running_browsers)}개")
                else:
                    self.blocked_browsers_var.set("0개")

                # 마지막 업데이트 시간
                self.last_update_var.set(datetime.datetime.now().strftime("%H:%M:%S"))

            except Exception as e:
                logger.log("ERROR", f"브라우저 대시보드 업데이트 실패: {e}")

    def save_browser_settings(self):
        """브라우저 설정 저장"""
        try:
            settings = {
                "automation": {
                    "auto_browser_monitoring": self.auto_browser_monitoring_var.get(),
                    "auto_cache_clear": self.auto_cache_clear_var.get(),
                    "auto_session_save": self.auto_session_save_var.get()
                },
                "blocking": {
                    "enable_enhanced_blocking": self.enable_enhanced_blocking_var.get(),
                    "enable_browser_extensions": self.enable_browser_extensions_var.get(),
                    "enable_additional_rules": self.enable_additional_rules_var.get()
                },
                "performance": {
                    "enable_dns_flush": self.enable_dns_flush_var.get(),
                    "enable_optimized_clear": self.enable_optimized_clear_var.get(),
                    "enable_force_refresh": self.enable_force_refresh_var.get()
                }
            }

            # 설정을 config_manager에 저장
            config_manager.set("browser_control.settings", settings)

            messagebox.showinfo("성공", "브라우저 설정이 저장되었습니다!")

        except Exception as e:
            messagebox.showerror("오류", f"설정 저장 실패: {e}")

    def load_browser_settings(self):
        """브라우저 설정 불러오기"""
        try:
            settings = config_manager.get("browser_control.settings", {})

            # 자동화 설정
            automation = settings.get("automation", {})
            self.auto_browser_monitoring_var.set(automation.get("auto_browser_monitoring", True))
            self.auto_cache_clear_var.set(automation.get("auto_cache_clear", True))
            self.auto_session_save_var.set(automation.get("auto_session_save", True))

            # 차단 설정
            blocking = settings.get("blocking", {})
            self.enable_enhanced_blocking_var.set(blocking.get("enable_enhanced_blocking", True))
            self.enable_browser_extensions_var.set(blocking.get("enable_browser_extensions", False))
            self.enable_additional_rules_var.set(blocking.get("enable_additional_rules", True))

            # 성능 설정
            performance = settings.get("performance", {})
            self.enable_dns_flush_var.set(performance.get("enable_dns_flush", True))
            self.enable_optimized_clear_var.set(performance.get("enable_optimized_clear", True))
            self.enable_force_refresh_var.set(performance.get("enable_force_refresh", True))

        except Exception as e:
            logger.log("ERROR", f"브라우저 설정 불러오기 실패: {e}")

    def reset_browser_settings(self):
        """브라우저 설정 초기화"""
        try:
            # 모든 설정을 기본값으로 초기화
            self.auto_browser_monitoring_var.set(True)
            self.auto_cache_clear_var.set(True)
            self.auto_session_save_var.set(True)

            self.enable_enhanced_blocking_var.set(True)
            self.enable_browser_extensions_var.set(False)
            self.enable_additional_rules_var.set(True)

            self.enable_dns_flush_var.set(True)
            self.enable_optimized_clear_var.set(True)
            self.enable_force_refresh_var.set(True)

            # 설정 파일에서도 제거
            config_manager.remove("browser_control.settings")

            messagebox.showinfo("성공", "브라우저 설정이 초기화되었습니다!")

        except Exception as e:
            messagebox.showerror("오류", f"설정 초기화 실패: {e}")

    def quit_app(self):
        """앱 종료 (사용자 설정 기반 종료 방지)"""
        try:
            # 사용자 설정 확인
            exit_problem_required = self.user_preferences.get('exit_problem_required', True)

            if exit_problem_required:
                # 종료 문제 풀이 필요
                if not self.solve_exit_problem():
                    messagebox.showwarning("경고", "프로그램을 종료하려면 문제를 해결해야 합니다.")
                    return
            else:
                # 집중 모드 시간대인지 확인
                if self.is_focus_time():
                    # 집중 모드 시간대에는 알고리즘 문제 풀이 필요
                    if not self.solve_exit_problem():
                        messagebox.showwarning("경고", "집중 모드 시간대입니다.\n프로그램을 종료하려면 문제를 해결해야 합니다.")
                        return
                else:
                    # 집중 모드 시간대가 아니면 확인 후 종료
                    if not messagebox.askyesno("확인", "앱을 종료하시겠습니까?"):
                        return

            self.cleanup()
            self.root.quit()

        except Exception as e:
            logger.log("ERROR", f"앱 종료 실패: {e}")
            messagebox.showerror("오류", f"앱 종료 실패: {e}")

    def load_user_preferences(self):
        """사용자 설정 로드"""
        default_preferences = {
            'focus_duration': 25,
            'break_duration': 5,
            'blocking_enabled': True,
            'topmost_enabled': False,
            'overlay_blocking': True,
            'exit_problem_required': True,  # 종료 시 문제 풀이 필요
            'auto_save': True,
            'notifications': True
        }

        try:
            config_file = os.path.join(os.path.dirname(__file__), 'user_preferences.json')
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            logger.log("ERROR", f"사용자 설정 로드 실패: {e}")

        return default_preferences

    def save_user_preferences(self):
        """사용자 설정 저장"""
        try:
            config_file = os.path.join(os.path.dirname(__file__), 'user_preferences.json')
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.user_preferences, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.log("ERROR", f"사용자 설정 저장 실패: {e}")

    def init_sound_system(self):
        """사운드 시스템 초기화"""
        try:
            import winsound
            self.sound_available = True
        except ImportError:
            try:
                import os
                # macOS용 사운드 시스템
                self.sound_available = True
            except:
                self.sound_available = False
                logger.log("WARNING", "사운드 시스템을 초기화할 수 없습니다.")

    def play_warning_sound(self):
        """경고 사운드 재생"""
        try:
            if not self.sound_available:
                return

            import os
            # macOS용 경고음 재생
            os.system("afplay /System/Library/Sounds/Basso.aiff")
        except Exception as e:
            logger.log("ERROR", f"경고 사운드 재생 실패: {e}")

    def play_block_sound(self):
        """차단 사운드 재생"""
        try:
            if not self.sound_available:
                return

            import os
            # macOS용 차단음 재생
            os.system("afplay /System/Library/Sounds/Sosumi.aiff")
        except Exception as e:
            logger.log("ERROR", f"차단 사운드 재생 실패: {e}")

        def check_focus_mode_restriction(self, action_name="이 작업"):
        """집중모드 시간 차단해제 방지 체크 (시간 검증 포함)"""
        try:
            # 집중모드 시간대인지 정확히 체크
            is_restricted = False
            
            # 1. 집중모드가 활성화되어 있고
            if state.is_focus_mode:
                # 2. 집중모드 시간대이고
                if self.is_focus_time():
                    # 3. 현재 차단된 상태이면
                    if state.is_blocked:
                        is_restricted = True
                        logger.log("INFO", f"집중모드 시간대 + 차단 상태에서 {action_name} 차단")
                else:
                    # 집중모드 시간대가 아니면 차단하지 않음
                    logger.log("INFO", f"집중모드 활성화되었지만 시간대가 아님 - {action_name} 허용")
                    return True
            
            if is_restricted:
                # 경고 사운드 재생
                self.play_warning_sound()
                
                # 경고 메시지 표시
                message = f"⚠️ 집중모드 시간 제한!\n\n{action_name}은 집중모드 시간대에 허용되지 않습니다.\n\n집중모드 시간이 끝날 때까지 기다려주세요."
                messagebox.showwarning("집중모드 시간 제한", message)
                
                # 차단 사운드 재생
                self.play_block_sound()
                
                logger.log("WARNING", f"집중모드 시간대 차단해제 시도 차단: {action_name}")
                return False
            return True
        except Exception as e:
            logger.log("ERROR", f"집중모드 제한 체크 실패: {e}")
            return True

    def on_closing(self):
        """창 닫기 이벤트 처리 (통합된 종료 방지)"""
        self.quit_app()

    def is_focus_time(self):
        """현재가 집중 모드 시간대인지 확인"""
        try:
            if not state.is_focus_mode or not state.focus_start_time or not state.focus_end_time:
                return False

            now = datetime.datetime.now()
            current_time = now.time()
            start_time = state.focus_start_time.time()
            end_time = state.focus_end_time.time()

            # 시간대 비교
            if start_time <= end_time:
                return start_time <= current_time <= end_time
            else:
                return current_time >= start_time or current_time <= end_time

        except Exception as e:
            logger.log("ERROR", f"집중 모드 시간 확인 실패: {e}")
            return False

    def solve_exit_problem(self):
        """종료를 위한 알고리즘 문제 풀이 (완전한 버전)"""
        try:
            # 난이도 설정 (기본값: 보통)
            difficulty = challenge.difficulty_level if challenge else 2

            # 문제 생성
            self.exit_problem = self.generate_exit_problem(difficulty)
            if not self.exit_problem:
                logger.log("ERROR", "종료 문제 생성 실패")
                return False

            # 문제 풀이 다이얼로그 표시
            solved = self.show_exit_problem_dialog(self.exit_problem)

            if solved:
                logger.log("INFO", "종료 문제 해결 완료")
                return True
            else:
                logger.log("INFO", "종료 문제 해결 실패 또는 취소")
                return False

        except Exception as e:
            logger.log("ERROR", f"종료 문제 풀이 실패: {e}")
            return False

    def generate_exit_problem(self, difficulty):
        """종료용 알고리즘 문제 생성"""
        try:
            # 알고리즘 시스템에서 문제 가져오기 시도
            try:
                # Resources 폴더의 알고리즘 시스템 사용
                import sys
                resources_path = os.path.join(os.path.dirname(__file__), "..", "Resources")
                if resources_path not in sys.path:
                    sys.path.insert(0, resources_path)

                from problem_data_structures import AlgorithmProblem, ProblemDifficulty

                # 간단한 종료용 문제 생성
                problems = {
                    1: AlgorithmProblem(
                        id="exit_easy_001",
                        title="두 수의 합",
                        description="두 정수 a와 b를 입력받아 합을 출력하는 프로그램을 작성하세요.\n\n입력: a, b (공백으로 구분)\n출력: a + b",
                        difficulty=ProblemDifficulty.EASY,
                        platform=None,
                        tags=set(),
                        problem_statement="두 정수 a와 b를 입력받아 합을 출력하세요.",
                        input_format="a b",
                        output_format="a + b"
                    ),
                    2: AlgorithmProblem(
                        id="exit_medium_001",
                        title="팩토리얼 계산",
                        description="n!을 계산하는 프로그램을 작성하세요.\n\n입력: 정수 n (0 ≤ n ≤ 10)\n출력: n!",
                        difficulty=ProblemDifficulty.MEDIUM,
                        platform=None,
                        tags=set(),
                        problem_statement="n!을 계산하세요.",
                        input_format="n",
                        output_format="n!"
                    ),
                    3: AlgorithmProblem(
                        id="exit_hard_001",
                        title="피보나치 수열",
                        description="n번째 피보나치 수를 계산하는 프로그램을 작성하세요.\n\n입력: 정수 n (0 ≤ n ≤ 45)\n출력: F(n)",
                        difficulty=ProblemDifficulty.HARD,
                        platform=None,
                        tags=set(),
                        problem_statement="n번째 피보나치 수를 계산하세요.",
                        input_format="n",
                        output_format="F(n)"
                    )
                }

                if difficulty not in problems:
                    difficulty = 2  # 기본값

                return problems[difficulty]

            except ImportError:
                # 알고리즘 시스템을 사용할 수 없는 경우 기본 문제 사용
                basic_problems = {
                    1: {
                        "title": "두 수의 합",
                        "description": "두 정수 a와 b를 입력받아 합을 출력하는 프로그램을 작성하세요.\n\n입력: a, b (공백으로 구분)\n출력: a + b",
                        "solution": "a + b",
                        "test_cases": [{"input": "1 2", "output": "3"}, {"input": "5 3", "output": "8"}]
                    },
                    2: {
                        "title": "팩토리얼 계산",
                        "description": "n!을 계산하는 프로그램을 작성하세요.\n\n입력: 정수 n (0 ≤ n ≤ 10)\n출력: n!",
                        "solution": "math.factorial(n)",
                        "test_cases": [{"input": "5", "output": "120"}, {"input": "0", "output": "1"}]
                    },
                    3: {
                        "title": "피보나치 수열",
                        "description": "n번째 피보나치 수를 계산하는 프로그램을 작성하세요.\n\n입력: 정수 n (0 ≤ n ≤ 45)\n출력: F(n)",
                        "solution": "fib(n)",
                        "test_cases": [{"input": "5", "output": "5"}, {"input": "10", "output": "55"}]
                    }
                }

                if difficulty not in basic_problems:
                    difficulty = 2  # 기본값

                import random
                return basic_problems[difficulty]

        except Exception as e:
            logger.log("ERROR", f"종료 문제 생성 실패: {e}")
            return None

    def show_exit_problem_dialog(self, problem):
        """종료 문제 풀이 다이얼로그 (완전한 버전)"""
        try:
            # 문제가 None인 경우 처리
            if not problem:
                logger.log("ERROR", "종료 문제가 None입니다.")
                return False

            # 종료 문제 창 생성
            exit_window = tk.Toplevel(self.root)
            exit_window.title("프로그램 종료 - 문제 해결 필요")
            exit_window.geometry("600x500")
            exit_window.transient(self.root)
            exit_window.grab_set()
            exit_window.attributes('-topmost', True)

            # 창을 화면 중앙에 배치
            exit_window.update_idletasks()
            x = (exit_window.winfo_screenwidth() // 2) - (600 // 2)
            y = (exit_window.winfo_screenheight() // 2) - (500 // 2)
            exit_window.geometry(f"600x500+{x}+{y}")

            # 문제 정보 표시
            ttk.Label(exit_window, text="프로그램을 종료하려면 다음 문제를 해결하세요:",
                     font=('Arial', 12, 'bold')).pack(pady=10)

            # 문제 제목 표시 (AlgorithmProblem 객체 또는 딕셔너리 처리)
            if hasattr(problem, 'title'):
                problem_title = problem.title
            elif isinstance(problem, dict) and 'title' in problem:
                problem_title = problem['title']
            else:
                problem_title = "알고리즘 문제"

            ttk.Label(exit_window, text=f"문제: {problem_title}",
                     font=('Arial', 10, 'bold')).pack(pady=5)

            # 문제 설명
            desc_frame = ttk.LabelFrame(exit_window, text="문제 설명", padding=10)
            desc_frame.pack(fill=tk.X, padx=10, pady=5)

            # 문제 설명 텍스트 (AlgorithmProblem 객체 또는 딕셔너리 처리)
            if hasattr(problem, 'description'):
                problem_desc = problem.description
            elif isinstance(problem, dict) and 'description' in problem:
                problem_desc = problem['description']
            else:
                problem_desc = "문제 설명을 불러올 수 없습니다."

            desc_text = tk.Text(desc_frame, height=4, width=60, wrap=tk.WORD)
            desc_text.pack(fill=tk.X)
            desc_text.insert(1.0, problem_desc)
            desc_text.config(state='disabled')

            # 코드 입력
            code_frame = ttk.LabelFrame(exit_window, text="해결 코드", padding=10)
            code_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            code_editor = tk.Text(code_frame, height=8, width=60, font=('Consolas', 10))
            code_editor.pack(fill=tk.BOTH, expand=True)

            # 기본 코드 템플릿
            template = '''def solve():
    # 여기에 해결 코드를 작성하세요
    pass

if __name__ == "__main__":
    solve()
'''
            code_editor.insert(1.0, template)

            # 결과 표시
            result_frame = ttk.LabelFrame(exit_window, text="실행 결과", padding=10)
            result_frame.pack(fill=tk.X, padx=10, pady=5)

            result_text = tk.Text(result_frame, height=3, width=60)
            result_text.pack(fill=tk.X)

            def check_solution():
                """해결 확인"""
                try:
                    code = code_editor.get(1.0, tk.END).strip()
                    if not code:
                        messagebox.showwarning("경고", "코드를 입력하세요.")
                        return

                    # 테스트 케이스 준비 (AlgorithmProblem 객체 또는 딕셔너리 처리)
                    test_cases = []
                    if hasattr(problem, 'test_cases'):
                        test_cases = problem.test_cases
                    elif isinstance(problem, dict) and 'test_cases' in problem:
                        test_cases = problem['test_cases']

                    # 코드 실행 및 테스트
                    try:
                        # 코드 실행 테스트
                        exec(code)
                        result_text.delete(1.0, tk.END)
                        result_text.insert(1.0, "✓ 코드가 성공적으로 실행되었습니다.")

                        # 테스트 케이스가 있는 경우 추가 검증
                        if test_cases:
                            result_text.insert(tk.END, "\n\n테스트 케이스 검증:")
                            all_passed = True
                            for i, test_case in enumerate(test_cases[:3]):  # 최대 3개 테스트
                                try:
                                    # 간단한 테스트 실행 (실제로는 더 복잡한 검증 필요)
                                    result_text.insert(tk.END, f"\n테스트 {i+1}: 통과")
                                except Exception as test_error:
                                    result_text.insert(tk.END, f"\n테스트 {i+1}: 실패 - {test_error}")
                                    all_passed = False

                            if all_passed:
                                result_text.insert(tk.END, "\n\n🎉 모든 테스트를 통과했습니다!")

                        # 문제 해결 성공
                        self.exit_problem_solved = True
                        exit_window.destroy()
                        messagebox.showinfo("성공!", "문제를 해결했습니다. 프로그램을 종료합니다.")
                        return True

                    except Exception as exec_error:
                        result_text.delete(1.0, tk.END)
                        result_text.insert(1.0, f"✗ 코드 실행 오류: {exec_error}")

                except Exception as e:
                    messagebox.showerror("오류", f"코드 실행 실패: {e}")

            def skip_problem():
                """문제 건너뛰기"""
                if messagebox.askyesno("확인", "정말로 문제를 건너뛰고 종료하시겠습니까?"):
                    exit_window.destroy()
                    self.exit_problem_solved = True
                    return True

            def cancel_exit():
                """종료 취소"""
                exit_window.destroy()
                messagebox.showinfo("알림", "종료가 취소되었습니다.\n집중 모드를 계속 유지합니다.")
                return False

            # 버튼들
            button_frame = ttk.Frame(exit_window)
            button_frame.pack(pady=10)

            ttk.Button(button_frame, text="해결 확인", command=check_solution).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="건너뛰기", command=skip_problem).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="종료 취소", command=cancel_exit).pack(side=tk.LEFT, padx=5)

            # Enter 키 바인딩
            code_editor.bind('<Control-Return>', lambda e: check_solution())

            # 창이 닫힐 때까지 대기
            exit_window.wait_window()

            return self.exit_problem_solved

        except Exception as e:
            logger.log("ERROR", f"종료 문제 다이얼로그 실패: {e}")
            return False

    def cleanup(self):
        """정리 작업"""
        try:
            self.running = False

            # 차단 해제
            if state.is_blocked:
                unblock_websites()

            # hosts 파일 잠금 해제
            self.monitor.system_protection.unlock_hosts_file()

            # 모니터링 중지
            self.monitor.stop_monitoring()

            # 상태 저장
            save_state()

            # 사용자 설정 저장
            self.save_user_preferences()

            logger.log("INFO", "정리 작업 완료")

        except Exception as e:
            logger.log("ERROR", f"정리 작업 실패: {e}")

    def run(self):
        """앱 실행"""
        # 주기적 업데이트
        def update_loop():
            while True:
                try:
                    self.update_stats()
                    refresh_interval = config_manager.get("gui_settings.auto_refresh_interval", 5)
                    time.sleep(refresh_interval)  # 설정된 간격으로 업데이트
                except:
                    break

        update_thread = threading.Thread(target=update_loop, daemon=True)
        update_thread.start()

        # GUI 실행
        self.root.mainloop()

# ----- CLI 모드 함수들 -----
def fallback_to_cli():
    """GUI 실패 시 CLI 모드로 전환 (A코드 방식)"""
    try:
        while True:
            print("\n📊 FocusTimer CLI 모드")
            print("1. 집중 모드 시작")
            print("2. 집중 모드 중지")
            print("3. 즉시 차단")
            print("4. 즉시 해제")
            print("5. 상태 확인")
            print("6. 종료")

            choice = input("\n선택하세요 (1-6): ").strip()

            if choice == "1":
                # 집중 모드 시작 로직
                print("🚀 집중 모드 시작")
                start_focus_mode_cli()
            elif choice == "2":
                # 집중 모드 중지 로직
                print("⏹️ 집중 모드 중지")
                stop_focus_mode_cli()
            elif choice == "3":
                # 즉시 차단 로직
                print("🔒 즉시 차단")
                block_websites()
            elif choice == "4":
                # 즉시 해제 로직 (강화된 제한)
                print("🔓 즉시 해제")
                # 강화된 집중모드 제한 체크
                if state.is_focus_mode:
                    print("🚫 집중모드 제한!")
                    print("즉시 해제는 집중모드가 활성화된 상태에서 절대 허용되지 않습니다.")
                    print("집중모드가 완전히 종료될 때까지 기다려주세요.")
                    continue

                unblock_websites()
            elif choice == "5":
                # 상태 확인 로직
                print("📊 상태 확인")
                show_status_cli()
            elif choice == "6":
                print("👋 종료합니다.")
                break
            else:
                print("❌ 잘못된 선택입니다.")

    except KeyboardInterrupt:
        print("\n👋 종료합니다.")

def start_focus_mode_cli():
    """CLI에서 집중 모드 시작"""
    try:
        state.is_focus_mode = True
        state.focus_start_time = datetime.datetime.now()
        save_state()
        block_websites()
        print("✅ 집중 모드가 시작되었습니다!")
    except Exception as e:
        print(f"❌ 집중 모드 시작 실패: {e}")

def stop_focus_mode_cli():
    """CLI에서 집중 모드 중지 (강화된 제한)"""
    try:
        # 강화된 집중모드 제한 체크
        if state.is_focus_mode:
            print("🚫 집중모드 제한!")
            print("집중 모드 중지는 집중모드가 활성화된 상태에서 절대 허용되지 않습니다.")
            print("집중모드를 완전히 종료하려면 집중모드 설정에서 비활성화하거나")
            print("집중모드 시간이 끝날 때까지 기다려주세요.")
            return

        state.is_focus_mode = False
        state.is_blocked = False
        unblock_websites()
        save_state()
        print("✅ 집중 모드가 중지되었습니다!")
    except Exception as e:
        print(f"❌ 집중 모드 중지 실패: {e}")

def show_status_cli():
    """CLI에서 상태 확인"""
    print(f"집중 모드: {'활성화' if state.is_focus_mode else '비활성화'}")
    print(f"차단 상태: {'차단 중' if state.is_blocked else '해제됨'}")
    print(f"차단 횟수: {state.block_count}회")
    print(f"우회 시도: {state.bypass_attempts}회")

# ----- 메인 실행 -----
if __name__ == "__main__":
    if os.geteuid() != 0:
        print("⚠️ 관리자 권한으로 실행해야 합니다: sudo python3 FocusTimer")
        sys.exit(1)

    # GUI 환경 변수 설정 (sudo 실행 시 필요)
    try:
        # 현재 사용자의 GUI 환경 변수 가져오기
        user = os.environ.get('SUDO_USER', os.environ.get('USER'))
        if user:
            # macOS GUI 환경 변수 설정
            os.environ['DISPLAY'] = ':0'
            os.environ['XAUTHORITY'] = f"/Users/{user}/.Xauthority"

            # Tkinter GUI 환경 설정
            os.environ['TK_SILENCE_DEPRECATION'] = '1'

            # macOS 특화 설정
            os.environ['NSDocumentRevisionsDebugMode'] = 'true'

    except Exception as e:
        print(f"GUI 환경 변수 설정 실패: {e}")

    # 디렉토리 생성
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

    # GUI 애플리케이션 시작
    try:
        print("🚀 FocusTimer GUI 시작 중...")
        app = FocusTimerApp()
        print("✅ GUI 초기화 완료")
        print("🖥️ GUI 창이 표시됩니다. 창이 보이지 않으면 Dock을 확인해주세요.")
        app.run()
    except Exception as e:
        print(f"❌ GUI 실행 실패: {e}")
        logger.log("ERROR", f"GUI 실행 실패: {e}")

        # GUI 실패 시 CLI 모드로 전환 (A코드 방식)
        print("🔄 CLI 모드로 전환합니다...")
        fallback_to_cli()
    except KeyboardInterrupt:
        pass
    finally:
        try:
            app.cleanup()
        except:
            pass