#!/usr/bin/env python3
"""
FocusTimer.app -  ì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ(hybrid) v2.0.0
í†µí•© ë¡œì§ + ì™¸ë¶€ ì„¤ì • ë¶„ë¦¬ = ìµœì ì˜ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
import time
import datetime
import os
import sys
import signal
import random
import subprocess
import json
import hashlib
import fcntl
import stat
import socket
import urllib.request
import urllib.error
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import psutil

# ----- ì•± ê²½ë¡œ ì„¤ì • -----
APP_ROOT = Path(__file__).parent.parent
RESOURCES_PATH = APP_ROOT / "Resources"
VENV_PATH = APP_ROOT.parent / "focus_timer_env"

# Python ê²½ë¡œ ì„¤ì • (ê°€ìƒí™˜ê²½ì´ ì—†ìœ¼ë©´ ì‹œìŠ¤í…œ Python ì‚¬ìš©)
if (VENV_PATH / "bin" / "python").exists():
    PYTHON_PATH = VENV_PATH / "bin" / "python"
else:
    PYTHON_PATH = Path("/usr/bin/python3")

# ----- ì•± ì •ë³´ ìƒìˆ˜ -----
PRODUCT_NAME = "FocusTimer"
VERSION = "2.0.0"

# ----- ì‹œìŠ¤í…œ ê²½ë¡œ ìƒìˆ˜ -----
STATE_PATH = "/Library/Application Support/FocusTimer/state.json"
LOG_PATH = "/var/log/FocusTimer/focus_timer.log"

# ----- ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤ -----
class ConfigManager:
    def __init__(self):
        self.config_path = RESOURCES_PATH / "config.json"
        self.state_path = STATE_PATH
        self.config = self.load_config()
        self.ensure_directories()

    def ensure_directories(self):
        """í•„ìš”í•œ ë””ë ‰í† ë¦¬ ìƒì„±"""
        os.makedirs(os.path.dirname(self.state_path), exist_ok=True)
        os.makedirs("/var/log/FocusTimer", exist_ok=True)

    def load_config(self):
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                return self.get_default_config()
        except Exception as e:
            print(f"ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
            return self.get_default_config()

    def get_default_config(self):
        """ê¸°ë³¸ ì„¤ì • ë°˜í™˜"""
        return {
            "app_info": {
                "name": "FocusTimer",
                "version": "2.0.0",
                "description": "Hybrid êµ¬ì¡° ì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ"
            },
            "system_paths": {
                "hosts_file": "/etc/hosts",
                "redirect_ip": "127.0.0.1",
                "backup_path": "/Library/Application Support/FocusTimer/hosts_backup",
                "lock_file": "/Library/Application Support/FocusTimer/focus_timer.lock",
                "log_path": LOG_PATH,
                "pid_file": "/var/run/focus_timer.pid"
            },
            "blocked_websites": {
                "youtube": [
                    "youtube.com", "www.youtube.com", "m.youtube.com", "youtu.be",
                    "youtube-nocookie.com", "www.youtube-nocookie.com",
                    "youtube.googleapis.com", "www.youtube.googleapis.com",
                    "youtubei.googleapis.com", "www.youtubei.googleapis.com",
                    "yt3.ggpht.com", "i.ytimg.com", "ytimg.com", "www.ytimg.com",
                    "googlevideo.com", "www.googlevideo.com",
                    "shorts.youtube.com", "www.shorts.youtube.com"
                ],
                "social_media": [
                    "facebook.com", "www.facebook.com", "instagram.com", "www.instagram.com",
                    "twitter.com", "www.twitter.com", "x.com", "www.x.com",
                    "tiktok.com", "www.tiktok.com", "reddit.com", "www.reddit.com"
                ],
                "gaming": [
                    "twitch.tv", "www.twitch.tv", "discord.com", "www.discord.com",
                    "steamcommunity.com", "www.steamcommunity.com"
                ],
                "entertainment": [
                    "netflix.com", "www.netflix.com", "disneyplus.com", "www.disneyplus.com",
                    "spotify.com", "www.spotify.com"
                ]
            },
            "focus_mode": {
                "default_start_time": "09:00",
                "default_end_time": "18:00",
                "default_difficulty": 1,
                "max_difficulty": 5,
                "max_attempts": 3,
                "auto_restart_browser": True,
                "force_browser_restart": True
            },
            "security": {
                "enable_system_protection": True,
                "enable_file_monitoring": True,
                "enable_firewall_rules": False,
                "enable_dns_cache_flush": True,
                "enable_browser_cache_clear": True,
                "lock_hosts_file": True,
                "monitor_hosts_changes": True,
                "enable_auto_recovery": True
            },
            "gui_settings": {
                "window_size": {
                    "width": 900,
                    "height": 700
                },
                "theme": "clam",
                "auto_refresh_interval": 5,
                "log_lines_to_show": 20,
                "enable_notifications": True
            },
            "browsers": {
                "supported": [
                    "Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"
                ],
                "cache_paths": {
                    "Google Chrome": [
                        "~/Library/Caches/Google/Chrome/Default/Cache",
                        "~/Library/Application Support/Google/Chrome/Default/Cache"
                    ],
                    "Safari": [
                        "~/Library/Caches/com.apple.Safari",
                        "~/Library/Safari/LocalStorage"
                    ]
                }
            }
        }

    def get(self, key_path, default=None):
        """ì  í‘œê¸°ë²•ìœ¼ë¡œ ì„¤ì • ê°’ ê°€ì ¸ì˜¤ê¸°"""
        keys = key_path.split('.')
        value = self.config
        try:
            for key in keys:
                value = value[key]
            return value
        except (KeyError, TypeError):
            return default

    def save_config(self):
        """ì„¤ì • íŒŒì¼ ì €ì¥"""
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"ì„¤ì • ì €ì¥ ì‹¤íŒ¨: {e}")

    def get_all_blocked_websites(self):
        """ëª¨ë“  ì°¨ë‹¨í•  ì›¹ì‚¬ì´íŠ¸ ëª©ë¡ ë°˜í™˜"""
        websites = []
        for category, sites in self.get("blocked_websites", {}).items():
            websites.extend(sites)
        return websites

# ----- ì „ì—­ ì„¤ì • ì¸ìŠ¤í„´ìŠ¤ -----
config_manager = ConfigManager()

# ----- ì „ì—­ ìƒíƒœ í´ë˜ìŠ¤ -----
class FocusTimerState:
    def __init__(self):
        self.is_focus_mode = False
        self.focus_start_time = None
        self.focus_end_time = None
        self.is_blocked = False
        self.hosts_hash = None
        self.last_check = None
        self.block_count = 0
        self.bypass_attempts = 0
        self.difficulty_level = 1
        self.failed_attempts = 0

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
state = FocusTimerState()
challenge = None

# ----- ë¡œê¹… ì‹œìŠ¤í…œ -----
class Logger:
    def __init__(self, log_file):
        self.log_file = log_file
        self.ensure_log_directory()

    def ensure_log_directory(self):
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)

    def log(self, level, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"

        # ì½˜ì†” ì¶œë ¥
        print(log_entry)

        # íŒŒì¼ ë¡œê¹…
        try:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")
        except:
            pass

logger = Logger(config_manager.get("system_paths.log_path"))

# ----- ì‹œìŠ¤í…œ ë ˆë²¨ ë³´í˜¸ -----
class SystemProtection:
    def __init__(self):
        self.original_hosts_permissions = None
        self.firewall_rules = []

    def backup_hosts_permissions(self):
        """hosts íŒŒì¼ ì›ë³¸ ê¶Œí•œ ë°±ì—…"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            stat_info = os.stat(hosts_path)
            self.original_hosts_permissions = stat_info.st_mode
            logger.log("INFO", "hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì‹¤íŒ¨: {e}")

    def lock_hosts_file(self):
        """hosts íŒŒì¼ì„ ì½ê¸° ì „ìš©ìœ¼ë¡œ ì ê¸ˆ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            os.chmod(hosts_path, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)  # 444
            logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ ì‹¤íŒ¨: {e}")

    def unlock_hosts_file(self):
        """hosts íŒŒì¼ ì ê¸ˆ í•´ì œ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            if self.original_hosts_permissions:
                os.chmod(hosts_path, self.original_hosts_permissions)
            else:
                os.chmod(hosts_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)  # 644
            logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì‹¤íŒ¨: {e}")

# ----- ì§€ì†ì  ëª¨ë‹ˆí„°ë§ -----
class HostsFileMonitor(FileSystemEventHandler):
    def __init__(self, focus_timer):
        self.focus_timer = focus_timer
        self.last_modified = 0

    def on_modified(self, event):
        hosts_path = config_manager.get("system_paths.hosts_file")
        if event.src_path == hosts_path:
            current_time = time.time()
            if current_time - self.last_modified > 1:  # ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€
                self.last_modified = current_time
                logger.log("WARNING", "hosts íŒŒì¼ ë³€ê²½ ê°ì§€ë¨")
                self.focus_timer.handle_hosts_modification()

class FocusTimerMonitor:
    def __init__(self):
        self.observer = None
        self.monitoring = False
        self.system_protection = SystemProtection()

    def start_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if not config_manager.get("security.enable_file_monitoring", True):
            return

        try:
            self.observer = Observer()
            event_handler = HostsFileMonitor(self)
            self.observer.schedule(event_handler, path="/etc", recursive=False)
            self.observer.start()
            self.monitoring = True
            logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        except Exception as e:
            logger.log("ERROR", f"ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì‹¤íŒ¨: {e}")

    def stop_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.monitoring = False
            logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€")

    def handle_hosts_modification(self):
        """hosts íŒŒì¼ ìˆ˜ì • ì²˜ë¦¬"""
        if state.is_focus_mode and state.is_blocked:
            logger.log("WARNING", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ hosts íŒŒì¼ ìˆ˜ì • ì‹œë„ ê°ì§€")
            state.bypass_attempts += 1

            # ìë™ìœ¼ë¡œ ì°¨ë‹¨ ì¬ì ìš©
            self.reapply_blocking()

            # ë³´ì•ˆ ê°•í™”
            self.enhance_security()

    def reapply_blocking(self):
        """ì°¨ë‹¨ ì¬ì ìš©"""
        try:
            # hosts íŒŒì¼ ì ê¸ˆ í•´ì œ
            self.system_protection.unlock_hosts_file()

            # ì°¨ë‹¨ ì„¤ì • ì¬ì ìš©
            block_websites()

            # hosts íŒŒì¼ ë‹¤ì‹œ ì ê¸ˆ
            if config_manager.get("security.lock_hosts_file", True):
                self.system_protection.lock_hosts_file()

            # DNS ìºì‹œ ì´ˆê¸°í™”
            if config_manager.get("security.enable_dns_cache_flush", True):
                self.flush_dns_cache()

            logger.log("INFO", "ì°¨ë‹¨ ì¬ì ìš© ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ì°¨ë‹¨ ì¬ì ìš© ì‹¤íŒ¨: {e}")

    def enhance_security(self):
        """ë³´ì•ˆ ê°•í™”"""
        try:
            # ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘
            if config_manager.get("focus_mode.force_browser_restart", True):
                self.restart_browsers()

            # ì‹œìŠ¤í…œ ì•Œë¦¼
            self.send_system_notification("ë³´ì•ˆ ê²½ê³ ", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ ì°¨ë‹¨ í•´ì œ ì‹œë„ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")

            logger.log("INFO", "ë³´ì•ˆ ê°•í™” ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ë³´ì•ˆ ê°•í™” ì‹¤íŒ¨: {e}")

    def flush_dns_cache(self):
        """DNS ìºì‹œ ì´ˆê¸°í™”"""
        try:
            subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
            subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
            logger.log("INFO", "DNS ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"DNS ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

    def restart_browsers(self):
        """ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘"""
        browsers = config_manager.get("browsers.supported", [])

        for browser in browsers:
            try:
                # ë¸Œë¼ìš°ì € ì¢…ë£Œ
                subprocess.run(["osascript", "-e", f'quit app "{browser}"'],
                             capture_output=True, timeout=5)
                time.sleep(2)

                # ê°•ì œ ì¢…ë£Œ
                subprocess.run(["pkill", "-f", browser], capture_output=True)
                time.sleep(1)

                # ì¬ì‹œì‘
                subprocess.run(["open", "-a", browser], capture_output=True)
                time.sleep(3)

                logger.log("INFO", f"{browser} ì¬ì‹œì‘ ì™„ë£Œ")

            except Exception as e:
                logger.log("ERROR", f"{browser} ì¬ì‹œì‘ ì‹¤íŒ¨: {e}")

    def send_system_notification(self, title, message):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        try:
            subprocess.run([
                "osascript", "-e",
                f'display notification "{message}" with title "{title}"'
            ], capture_output=True)
        except:
            pass

# ----- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì‹œìŠ¤í…œ -----
class AlgorithmChallenge:
    def __init__(self):
        self.difficulty_level = config_manager.get("focus_mode.default_difficulty", 1)
        self.max_attempts = config_manager.get("focus_mode.max_attempts", 3)
        self.failed_attempts = 0

    def generate_problem(self):
        """ë‚œì´ë„ì— ë”°ë¥¸ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ìƒì„±"""
        if self.difficulty_level == 1:
            # ê¸°ë³¸ ì‚¬ì¹™ì—°ì‚°
            a = random.randint(10, 99)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 2:
            # 3ìë¦¬ ìˆ˜ ì—°ì‚°
            a = random.randint(100, 999)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 3:
            # ë³µí•© ì—°ì‚°
            a = random.randint(10, 50)
            b = random.randint(5, 20)
            c = random.randint(2, 10)

            answer = (a + b) * c
            return f"({a} + {b}) Ã— {c} = ?", answer

        elif self.difficulty_level == 4:
            # í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´
            n = random.randint(5, 10)
            fib_sequence = [0, 1]
            for i in range(2, n + 1):
                fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
            answer = fib_sequence[n]
            return f"í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì˜ {n}ë²ˆì§¸ ìˆ˜ëŠ”? (F(0)=0, F(1)=1)", answer

        else:  # ë‚œì´ë„ 5
            # ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ
            numbers = [random.randint(1, 100) for _ in range(5)]
            sorted_numbers = sorted(numbers)
            answer = sorted_numbers[2]  # ì¤‘ê°„ê°’
            return f"ìˆ«ì {numbers}ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í–ˆì„ ë•Œ ì¤‘ê°„ê°’ì€?", answer

    def increase_difficulty(self):
        """ë‚œì´ë„ ì¦ê°€"""
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        if self.difficulty_level < max_difficulty:
            self.difficulty_level += 1
            logger.log("INFO", f"ë‚œì´ë„ê°€ {self.difficulty_level}ë¡œ ì¦ê°€")

    def ask_challenge(self):
        """ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì¶œì œ ë° ì •ë‹µ í™•ì¸"""
        logger.log("INFO", f"ë‚œì´ë„ {self.difficulty_level} ë¬¸ì œ ì¶œì œ")

        attempts = 0
        while attempts < self.max_attempts:
            problem, answer = self.generate_problem()
            print(f"\nğŸ“ ë¬¸ì œ: {problem}")

            try:
                user_input = input("ë‹µ: ").strip()

                if user_input.isdigit():
                    user_answer = int(user_input)
                else:
                    print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                    attempts += 1
                    continue

                if user_answer == answer:
                    logger.log("INFO", "ë¬¸ì œ í•´ê²° ì„±ê³µ")
                    return True
                else:
                    attempts += 1
                    remaining = self.max_attempts - attempts
                    print(f"âŒ ì˜¤ë‹µì…ë‹ˆë‹¤. ì •ë‹µ: {answer}")
                    if remaining > 0:
                        print(f"ğŸ”„ ë‚¨ì€ ì‹œë„: {remaining}")
                    else:
                        print("ğŸš« ëª¨ë“  ì‹œë„ ì‹¤íŒ¨!")

            except KeyboardInterrupt:
                print("\nâš ï¸ ë¬¸ì œ í’€ì´ë¥¼ ì¤‘ë‹¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
                attempts += 1
            except:
                print("âš ï¸ ì˜¬ë°”ë¥¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                attempts += 1

        # ëª¨ë“  ì‹œë„ ì‹¤íŒ¨
        self.failed_attempts += 1
        if self.failed_attempts >= 2:
            self.increase_difficulty()
            self.failed_attempts = 0

        logger.log("WARNING", "ë¬¸ì œ í•´ê²° ì‹¤íŒ¨ - ì¢…ë£Œ ê±°ë¶€")
        return False

# ----- ë‹¤ì¤‘ ì°¨ë‹¨ ë ˆì´ì–´ -----
def block_websites():
    """ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ ì ìš©"""
    try:
        # 1. hosts íŒŒì¼ ì°¨ë‹¨
        block_hosts_file()

        # 2. DNS ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        # 3. ë¸Œë¼ìš°ì € ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_browser_cache_clear", True):
            clear_browser_cache()

        state.is_blocked = True
        state.block_count += 1
        logger.log("INFO", "ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ ì ìš© ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ì°¨ë‹¨ ì ìš© ì‹¤íŒ¨: {e}")

def unblock_websites():
    """ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ í•´ì œ"""
    try:
        # 1. hosts íŒŒì¼ ë³µêµ¬
        restore_hosts_file()

        # 2. DNS ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        state.is_blocked = False
        logger.log("INFO", "ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ í•´ì œ ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ì°¨ë‹¨ í•´ì œ ì‹¤íŒ¨: {e}")

def block_hosts_file():
    """hosts íŒŒì¼ì— ì°¨ë‹¨ ì„¤ì • ì¶”ê°€"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")
        redirect_ip = config_manager.get("system_paths.redirect_ip")
        websites = config_manager.get_all_blocked_websites()

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            # FocusTimer ë¸”ë¡ ì‹œì‘/ë ë§ˆì»¤
            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            # ê¸°ì¡´ ë¸”ë¡ ì œê±°
            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                lines = lines[:start_idx] + lines[end_idx + 1:]

            # ìƒˆë¡œìš´ ì°¨ë‹¨ ì„¤ì • ì¶”ê°€
            new_entries = [block_start]
            for site in websites:
                new_entries.append(f"{redirect_ip} {site}\n")
            new_entries.append(block_end)

            # íŒŒì¼ì— ì“°ê¸°
            file.seek(0)
            file.writelines(lines + new_entries)
            file.truncate()
            file.flush()
            os.fsync(file.fileno())

            logger.log("INFO", "hosts íŒŒì¼ ì°¨ë‹¨ ì„¤ì • ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"hosts íŒŒì¼ ì°¨ë‹¨ ì‹¤íŒ¨: {e}")

def restore_hosts_file():
    """hosts íŒŒì¼ì—ì„œ ì°¨ë‹¨ ì„¤ì • ì œê±°"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                new_lines = lines[:start_idx] + lines[end_idx + 1:]
                file.seek(0)
                file.writelines(new_lines)
                file.truncate()
                file.flush()
                os.fsync(file.fileno())

                logger.log("INFO", "hosts íŒŒì¼ ë³µêµ¬ ì™„ë£Œ")
            else:
                logger.log("INFO", "ì°¨ë‹¨ ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.")

    except Exception as e:
        logger.log("ERROR", f"hosts íŒŒì¼ ë³µêµ¬ ì‹¤íŒ¨: {e}")

def flush_dns_cache():
    """DNS ìºì‹œ ì´ˆê¸°í™”"""
    try:
        subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
        subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
        logger.log("INFO", "DNS ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
    except Exception as e:
        logger.log("ERROR", f"DNS ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

def clear_browser_cache():
    """ë¸Œë¼ìš°ì € ìºì‹œ ì´ˆê¸°í™”"""
    browsers = config_manager.get("browsers.supported", [])
    cache_paths = config_manager.get("browsers.cache_paths", {})

    for browser in browsers:
        try:
            if browser in cache_paths:
                for path in cache_paths[browser]:
                    expanded_path = os.path.expanduser(path)
                    if os.path.exists(expanded_path):
                        subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

            logger.log("INFO", f"{browser} ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"{browser} ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

# ----- ìƒíƒœ ê´€ë¦¬ -----
def save_state():
    """ìƒíƒœ ì €ì¥"""
    try:
        state_data = {
            "is_focus_mode": state.is_focus_mode,
            "focus_start_time": state.focus_start_time.isoformat() if state.focus_start_time else None,
            "focus_end_time": state.focus_end_time.isoformat() if state.focus_end_time else None,
            "is_blocked": state.is_blocked,
            "block_count": state.block_count,
            "bypass_attempts": state.bypass_attempts,
            "difficulty_level": challenge.difficulty_level if challenge else 1,
            "failed_attempts": challenge.failed_attempts if challenge else 0,
            "last_check": datetime.datetime.now().isoformat()
        }

        with open(config_manager.state_path, "w") as f:
            json.dump(state_data, f, indent=2)

        logger.log("INFO", "ìƒíƒœ ì €ì¥ ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: {e}")

def load_state():
    """ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°"""
    try:
        if os.path.exists(config_manager.state_path):
            with open(config_manager.state_path, "r") as f:
                state_data = json.load(f)

            state.is_focus_mode = state_data.get("is_focus_mode", False)
            state.is_blocked = state_data.get("is_blocked", False)
            state.block_count = state_data.get("block_count", 0)
            state.bypass_attempts = state_data.get("bypass_attempts", 0)

            if state_data.get("focus_start_time"):
                state.focus_start_time = datetime.datetime.fromisoformat(state_data["focus_start_time"])
            if state_data.get("focus_end_time"):
                state.focus_end_time = datetime.datetime.fromisoformat(state_data["focus_end_time"])

            if challenge:
                challenge.difficulty_level = state_data.get("difficulty_level", 1)
                challenge.failed_attempts = state_data.get("failed_attempts", 0)

            logger.log("INFO", "ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

# ----- GUI ì• í”Œë¦¬ì¼€ì´ì…˜ -----
class FocusTimerApp:
    def __init__(self):
        global challenge
        challenge = AlgorithmChallenge()
        self.monitor = FocusTimerMonitor()
        self.running = False
        self.monitor_thread = None

        # GUI ì´ˆê¸°í™”
        self.root = tk.Tk()
        self.setup_gui()

        # ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
        load_state()

        # ì‹œìŠ¤í…œ ë³´í˜¸ ì´ˆê¸°í™”
        if config_manager.get("security.enable_system_protection", True):
            self.monitor.system_protection.backup_hosts_permissions()

    def setup_gui(self):
        """GUI ì„¤ì •"""
        app_name = config_manager.get("app_info.name", "FocusTimer")
        app_version = config_manager.get("app_info.version", "2.0.0")

        self.root.title(f"{app_name} v{app_version}")

        window_size = config_manager.get("gui_settings.window_size", {"width": 900, "height": 700})
        self.root.geometry(f"{window_size['width']}x{window_size['height']}")
        self.root.resizable(True, True)

        # ìŠ¤íƒ€ì¼ ì„¤ì •
        style = ttk.Style()
        theme = config_manager.get("gui_settings.theme", "clam")
        style.theme_use(theme)

        # ë©”ë‰´ë°” ì„¤ì •
        self.setup_menu()

        # ë©”ì¸ í”„ë ˆì„
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # ì œëª©
        title_label = ttk.Label(main_frame, text=f"â° {app_name}",
                               font=('Helvetica', 20, 'bold'))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))

        # íƒ­ ìƒì„±
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))

        # íƒ­ ì¶”ê°€
        self.create_dashboard_tab()
        self.create_timer_tab()
        self.create_settings_tab()
        self.create_stats_tab()

        # ìƒíƒœë°”
        self.status_var = tk.StringVar(value="ì¤€ë¹„ë¨")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var,
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))

        # ê·¸ë¦¬ë“œ ê°€ì¤‘ì¹˜
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)

    def setup_menu(self):
        """ë©”ë‰´ë°” ì„¤ì •"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # íŒŒì¼ ë©”ë‰´
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="íŒŒì¼", menu=file_menu)
        file_menu.add_command(label="ì„¤ì • ë‚´ë³´ë‚´ê¸°", command=self.export_config)
        file_menu.add_command(label="ì„¤ì • ê°€ì ¸ì˜¤ê¸°", command=self.import_config)
        file_menu.add_separator()
        file_menu.add_command(label="ì¢…ë£Œ", command=self.quit_app)

        # ë„êµ¬ ë©”ë‰´
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="ë„êµ¬", menu=tools_menu)
        tools_menu.add_command(label="CLI ëª¨ë“œ", command=self.open_cli)
        tools_menu.add_command(label="ì›¹ ì¸í„°í˜ì´ìŠ¤", command=self.open_web)
        tools_menu.add_separator()
        tools_menu.add_command(label="ë¡œê·¸ ë³´ê¸°", command=self.view_logs)

        # ë„ì›€ë§ ë©”ë‰´
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="ë„ì›€ë§", menu=help_menu)
        help_menu.add_command(label="ì‚¬ìš©ë²•", command=self.show_help)
        help_menu.add_command(label="ì •ë³´", command=self.show_about)

    def create_dashboard_tab(self):
        """ëŒ€ì‹œë³´ë“œ íƒ­"""
        dashboard_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(dashboard_frame, text="ğŸ“Š ëŒ€ì‹œë³´ë“œ")

        # í˜„ì¬ ìƒíƒœ
        status_frame = ttk.LabelFrame(dashboard_frame, text="í˜„ì¬ ìƒíƒœ", padding="10")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.status_label = ttk.Label(status_frame, text="ì§‘ì¤‘ ëª¨ë“œ ë¹„í™œì„±í™”",
                                     font=('Helvetica', 14))
        self.status_label.grid(row=0, column=0, sticky=tk.W)

        # ë¹ ë¥¸ ì•¡ì…˜
        action_frame = ttk.LabelFrame(dashboard_frame, text="ë¹ ë¥¸ ì•¡ì…˜", padding="10")
        action_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Button(action_frame, text="ğŸš€ ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘",
                  command=self.start_focus_mode).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(action_frame, text="â¹ï¸ ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€",
                  command=self.stop_focus_mode).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(action_frame, text="ğŸ”’ ì¦‰ì‹œ ì°¨ë‹¨",
                  command=self.block_now).grid(row=0, column=2, padx=(0, 10))
        ttk.Button(action_frame, text="ğŸ”“ ì¦‰ì‹œ í•´ì œ",
                  command=self.unblock_now).grid(row=0, column=3)

    def create_timer_tab(self):
        """íƒ€ì´ë¨¸ ì„¤ì • íƒ­"""
        timer_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(timer_frame, text="â° íƒ€ì´ë¨¸")

        # ì‹œê°„ ì„¤ì •
        time_frame = ttk.LabelFrame(timer_frame, text="ì‹œê°„ ì„¤ì •", padding="10")
        time_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Label(time_frame, text="ì‹œì‘ ì‹œê°„:").grid(row=0, column=0, sticky=tk.W)
        self.start_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_start_time", "09:00"))
        ttk.Entry(time_frame, textvariable=self.start_time_var, width=10).grid(row=0, column=1, padx=(10, 0))

        ttk.Label(time_frame, text="ì¢…ë£Œ ì‹œê°„:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        self.end_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_end_time", "18:00"))
        ttk.Entry(time_frame, textvariable=self.end_time_var, width=10).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # ë‚œì´ë„ ì„¤ì •
        difficulty_frame = ttk.LabelFrame(timer_frame, text="ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ë‚œì´ë„", padding="10")
        difficulty_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.difficulty_var = tk.IntVar(value=config_manager.get("focus_mode.default_difficulty", 1))
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        for i in range(1, max_difficulty + 1):
            ttk.Radiobutton(difficulty_frame, text=f"ë‚œì´ë„ {i}",
                           variable=self.difficulty_var, value=i).grid(row=0, column=i-1, padx=(0, 10))

    def create_settings_tab(self):
        """ì„¤ì • íƒ­"""
        settings_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(settings_frame, text="âš™ï¸ ì„¤ì •")

        # ì¼ë°˜ ì„¤ì •
        general_frame = ttk.LabelFrame(settings_frame, text="ì¼ë°˜ ì„¤ì •", padding="10")
        general_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_start_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(general_frame, text="ì‹œìŠ¤í…œ ì‹œì‘ ì‹œ ìë™ ì‹¤í–‰",
                       variable=self.auto_start_var).grid(row=0, column=0, sticky=tk.W)

        self.browser_restart_var = tk.BooleanVar(value=config_manager.get("focus_mode.auto_restart_browser", True))
        ttk.Checkbutton(general_frame, text="ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ ì‹œ ë¸Œë¼ìš°ì € ì¬ì‹œì‘",
                       variable=self.browser_restart_var).grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        # ë³´ì•ˆ ì„¤ì •
        security_frame = ttk.LabelFrame(settings_frame, text="ë³´ì•ˆ ì„¤ì •", padding="10")
        security_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.file_monitoring_var = tk.BooleanVar(value=config_manager.get("security.enable_file_monitoring", True))
        ttk.Checkbutton(security_frame, text="íŒŒì¼ ëª¨ë‹ˆí„°ë§ í™œì„±í™”",
                       variable=self.file_monitoring_var).grid(row=0, column=0, sticky=tk.W)

        self.auto_recovery_var = tk.BooleanVar(value=config_manager.get("security.enable_auto_recovery", True))
        ttk.Checkbutton(security_frame, text="ìë™ ë³µêµ¬ í™œì„±í™”",
                       variable=self.auto_recovery_var).grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

    def create_stats_tab(self):
        """í†µê³„ íƒ­"""
        stats_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(stats_frame, text="ğŸ“ˆ í†µê³„")

        # í†µê³„ ì •ë³´
        stats_info_frame = ttk.LabelFrame(stats_frame, text="ì‚¬ìš© í†µê³„", padding="10")
        stats_info_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.total_focus_time_var = tk.StringVar(value="0ì‹œê°„")
        ttk.Label(stats_info_frame, text="ì´ ì§‘ì¤‘ ì‹œê°„:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(stats_info_frame, textvariable=self.total_focus_time_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        self.block_count_var = tk.StringVar(value="0íšŒ")
        ttk.Label(stats_info_frame, text="ì°¨ë‹¨ íšŸìˆ˜:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(stats_info_frame, textvariable=self.block_count_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        self.bypass_attempts_var = tk.StringVar(value="0íšŒ")
        ttk.Label(stats_info_frame, text="ìš°íšŒ ì‹œë„:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(stats_info_frame, textvariable=self.bypass_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

    def start_focus_mode(self):
        """ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘"""
        try:
            # ì‹œê°„ íŒŒì‹±
            start_time = self.start_time_var.get()
            end_time = self.end_time_var.get()

            start_hour, start_minute = map(int, start_time.split(':'))
            end_hour, end_minute = map(int, end_time.split(':'))

            # ìƒíƒœ ì„¤ì •
            now = datetime.datetime.now()
            state.focus_start_time = now.replace(hour=start_hour, minute=start_minute, second=0, microsecond=0)
            state.focus_end_time = now.replace(hour=end_hour, minute=end_minute, second=0, microsecond=0)
            state.is_focus_mode = True

            if challenge:
                challenge.difficulty_level = self.difficulty_var.get()

            save_state()

            # ëª¨ë‹ˆí„°ë§ ì‹œì‘
            if not self.running:
                self.start_monitoring()

            self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ í™œì„±í™”")
            self.status_var.set("ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ë¨")
            messagebox.showinfo("ì„±ê³µ", "ì§‘ì¤‘ ëª¨ë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!")

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ ì‹¤íŒ¨: {e}")

    def stop_focus_mode(self):
        """ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€"""
        try:
            state.is_focus_mode = False
            state.is_blocked = False

            # ì°¨ë‹¨ í•´ì œ
            unblock_websites()

            save_state()

            self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ ë¹„í™œì„±í™”")
            self.status_var.set("ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€ë¨")
            messagebox.showinfo("ì„±ê³µ", "ì§‘ì¤‘ ëª¨ë“œê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!")

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€ ì‹¤íŒ¨: {e}")

    def block_now(self):
        """ì¦‰ì‹œ ì°¨ë‹¨"""
        try:
            block_websites()
            messagebox.showinfo("ì•Œë¦¼", "ì›¹ì‚¬ì´íŠ¸ê°€ ì¦‰ì‹œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤!")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì¦‰ì‹œ ì°¨ë‹¨ ì‹¤íŒ¨: {e}")

    def unblock_now(self):
        """ì¦‰ì‹œ í•´ì œ"""
        try:
            unblock_websites()
            messagebox.showinfo("ì•Œë¦¼", "ì›¹ì‚¬ì´íŠ¸ ì°¨ë‹¨ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤!")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì¦‰ì‹œ í•´ì œ ì‹¤íŒ¨: {e}")

    def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if not self.running:
            self.running = True
            self.monitor.start_monitoring()

            # ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
            self.monitor_thread = threading.Thread(target=self.monitoring_loop, daemon=True)
            self.monitor_thread.start()

    def monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while self.running:
            try:
                self.check_focus_time()
                time.sleep(60)  # 1ë¶„ë§ˆë‹¤ ì²´í¬
            except Exception as e:
                logger.log("ERROR", f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {e}")

    def check_focus_time(self):
        """ì§‘ì¤‘ ì‹œê°„ ì²´í¬"""
        if not state.is_focus_mode:
            return

        now = datetime.datetime.now()
        current_time = now.time()

        if state.focus_start_time and state.focus_end_time:
            start_time = state.focus_start_time.time()
            end_time = state.focus_end_time.time()

            # ì‹œê°„ëŒ€ ë¹„êµ
            if start_time <= end_time:
                should_be_blocked = start_time <= current_time <= end_time
            else:
                should_be_blocked = current_time >= start_time or current_time <= end_time

            # ìƒíƒœ ë³€ê²½ ì²˜ë¦¬
            if state.is_blocked != should_be_blocked:
                if should_be_blocked:
                    block_websites()
                    self.monitor.system_protection.lock_hosts_file()
                    logger.log("INFO", "ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ - ì°¨ë‹¨ ì ìš©")
                else:
                    unblock_websites()
                    self.monitor.system_protection.unlock_hosts_file()
                    logger.log("INFO", "ì§‘ì¤‘ ëª¨ë“œ ì¢…ë£Œ - ì°¨ë‹¨ í•´ì œ")

                state.is_blocked = should_be_blocked
                save_state()

    def export_config(self):
        """ì„¤ì • ë‚´ë³´ë‚´ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì„¤ì • ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥")

    def import_config(self):
        """ì„¤ì • ê°€ì ¸ì˜¤ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì„¤ì • ê°€ì ¸ì˜¤ê¸° ê¸°ëŠ¥")

    def open_cli(self):
        """CLI ëª¨ë“œ ì—´ê¸°"""
        cli_path = APP_ROOT / "MacOS" / "FocusTimerCLI"
        if cli_path.exists():
            try:
                subprocess.Popen([str(PYTHON_PATH), str(cli_path)])
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"CLI ëª¨ë“œ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        else:
            messagebox.showerror("ì˜¤ë¥˜", f"CLI íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {cli_path}")

    def open_web(self):
        """ì›¹ ì¸í„°í˜ì´ìŠ¤ ì—´ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì›¹ ì¸í„°í˜ì´ìŠ¤ê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦½ë‹ˆë‹¤!")

    def view_logs(self):
        """ë¡œê·¸ ë³´ê¸°"""
        log_path = LOG_PATH
        if os.path.exists(log_path):
            try:
                subprocess.run(["open", "-a", "Console", log_path])
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"ë¡œê·¸ íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨: {e}")
        else:
            messagebox.showinfo("ì•Œë¦¼", "ë¡œê·¸ íŒŒì¼ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

    def show_help(self):
        """ë„ì›€ë§ ë³´ê¸°"""
        messagebox.showinfo("ë„ì›€ë§", "FocusTimer ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”!")

    def show_about(self):
        """ì •ë³´ ë³´ê¸°"""
        messagebox.showinfo("ì •ë³´", f"{PRODUCT_NAME} v{VERSION}\nì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ")

    def quit_app(self):
        """ì•± ì¢…ë£Œ"""
        if messagebox.askyesno("í™•ì¸", "ì•±ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            self.cleanup()
            self.root.quit()

    def cleanup(self):
        """ì •ë¦¬ ì‘ì—…"""
        try:
            self.running = False

            # ì°¨ë‹¨ í•´ì œ
            if state.is_blocked:
                unblock_websites()

            # hosts íŒŒì¼ ì ê¸ˆ í•´ì œ
            self.monitor.system_protection.unlock_hosts_file()

            # ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
            self.monitor.stop_monitoring()

            # ìƒíƒœ ì €ì¥
            save_state()

            logger.log("INFO", "ì •ë¦¬ ì‘ì—… ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ì •ë¦¬ ì‘ì—… ì‹¤íŒ¨: {e}")

    def run(self):
        """ì•± ì‹¤í–‰"""
        # GUI ì‹¤í–‰
        self.root.mainloop()

# ----- ë©”ì¸ ì‹¤í–‰ -----
if __name__ == "__main__":
    if os.geteuid() != 0:
        print("âš ï¸ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤: sudo python3 FocusTimer")
        sys.exit(1)

    # ë””ë ‰í† ë¦¬ ìƒì„±
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

    # GUI ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
    app = FocusTimerApp()

    try:
        app.run()
    except KeyboardInterrupt:
        pass
    finally:
        app.cleanup()