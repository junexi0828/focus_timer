#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
FocusTimer.app -  ì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ(hybrid) v2.0.0
í†µí•© ë¡œì§ + ì™¸ë¶€ ì„¤ì • ë¶„ë¦¬ = ìµœì ì˜ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
import time
import datetime
import os
import sys
import signal
import random
import subprocess
import json
import hashlib
import fcntl
import stat
import socket
import urllib.request
import urllib.error
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import psutil

# ----- ì•± ê²½ë¡œ ì„¤ì • -----
APP_ROOT = Path(__file__).parent.parent
RESOURCES_PATH = APP_ROOT / "Resources"

# ì•± ë‚´ë¶€ ê°€ìƒí™˜ê²½ ê²½ë¡œ ì„¤ì •
APP_VENV_PATH = Path(__file__).parent / "venv"
EXTERNAL_VENV_PATH = APP_ROOT.parent / "focus_timer_env"

# Python ê²½ë¡œ ì„¤ì • (ìš°ì„ ìˆœìœ„: ì•± ë‚´ë¶€ ê°€ìƒí™˜ê²½ > ì™¸ë¶€ ê°€ìƒí™˜ê²½ > ì‹œìŠ¤í…œ Python)
if (APP_VENV_PATH / "bin" / "python").exists():
    PYTHON_PATH = APP_VENV_PATH / "bin" / "python"
    print(f"ğŸ”— ì•± ë‚´ë¶€ ê°€ìƒí™˜ê²½ ì‚¬ìš©: {PYTHON_PATH}")
elif (EXTERNAL_VENV_PATH / "bin" / "python").exists():
    PYTHON_PATH = EXTERNAL_VENV_PATH / "bin" / "python"
    print(f"ğŸ”— ì™¸ë¶€ ê°€ìƒí™˜ê²½ ì‚¬ìš©: {PYTHON_PATH}")
else:
    PYTHON_PATH = Path("/usr/bin/python3")
    print(f"ğŸ”— ì‹œìŠ¤í…œ Python ì‚¬ìš©: {PYTHON_PATH}")

# ----- ì•± ì •ë³´ ìƒìˆ˜ -----
PRODUCT_NAME = "FocusTimer"
VERSION = "2.0.0"

# ----- ì‹œìŠ¤í…œ ê²½ë¡œ ìƒìˆ˜ -----
STATE_PATH = "/Library/Application Support/FocusTimer/state.json"
LOG_PATH = "/var/log/FocusTimer/focus_timer.log"

# ----- ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤ -----
class ConfigManager:
    def __init__(self):
        self.config_path = RESOURCES_PATH / "config.json"
        self.state_path = STATE_PATH
        self.config = self.load_config()
        self.ensure_directories()

    def ensure_directories(self):
        """í•„ìš”í•œ ë””ë ‰í† ë¦¬ ìƒì„±"""
        os.makedirs(os.path.dirname(self.state_path), exist_ok=True)
        os.makedirs("/var/log/FocusTimer", exist_ok=True)

    def load_config(self):
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                return self.get_default_config()
        except Exception as e:
            print(f"ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
            return self.get_default_config()

    def get_default_config(self):
        """ê¸°ë³¸ ì„¤ì • ë°˜í™˜"""
        return {
            "app_info": {
                "name": "FocusTimer",
                "version": "2.0.0",
                "description": "Hybrid êµ¬ì¡° ì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ"
            },
            "system_paths": {
                "hosts_file": "/etc/hosts",
                "redirect_ip": "127.0.0.1",
                "backup_path": "/Library/Application Support/FocusTimer/hosts_backup",
                "lock_file": "/Library/Application Support/FocusTimer/focus_timer.lock",
                "log_path": LOG_PATH,
                "pid_file": "/var/run/focus_timer.pid"
            },
            "blocked_websites": {
                "youtube": [
                    "youtube.com", "www.youtube.com", "m.youtube.com", "youtu.be",
                    "youtube-nocookie.com", "www.youtube-nocookie.com",
                    "youtube.googleapis.com", "www.youtube.googleapis.com",
                    "youtubei.googleapis.com", "www.youtubei.googleapis.com",
                    "yt3.ggpht.com", "i.ytimg.com", "ytimg.com", "www.ytimg.com",
                    "googlevideo.com", "www.googlevideo.com",
                    "shorts.youtube.com", "www.shorts.youtube.com"
                ],
                "social_media": [
                    "facebook.com", "www.facebook.com", "instagram.com", "www.instagram.com",
                    "twitter.com", "www.twitter.com", "x.com", "www.x.com",
                    "tiktok.com", "www.tiktok.com", "reddit.com", "www.reddit.com"
                ],
                "gaming": [
                    "twitch.tv", "www.twitch.tv", "discord.com", "www.discord.com",
                    "steamcommunity.com", "www.steamcommunity.com"
                ],
                "entertainment": [
                    "netflix.com", "www.netflix.com", "disneyplus.com", "www.disneyplus.com",
                    "spotify.com", "www.spotify.com"
                ]
            },
            "focus_mode": {
                "default_start_time": "09:00",
                "default_end_time": "18:00",
                "default_difficulty": 1,
                "max_difficulty": 5,
                "max_attempts": 3,
                "auto_restart_browser": True,
                "force_browser_restart": True
            },
            "security": {
                "enable_system_protection": True,
                "enable_file_monitoring": True,
                "enable_firewall_rules": False,
                "enable_dns_cache_flush": True,
                "enable_browser_cache_clear": True,
                "lock_hosts_file": True,
                "monitor_hosts_changes": True,
                "enable_auto_recovery": True
            },
            "gui_settings": {
                "window_size": {
                    "width": 900,
                    "height": 700
                },
                "theme": "clam",
                "auto_refresh_interval": 5,
                "log_lines_to_show": 20,
                "enable_notifications": True
            },
            "browsers": {
                "supported": [
                    "Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"
                ],
                "cache_paths": {
                    "Google Chrome": [
                        "~/Library/Caches/Google/Chrome/Default/Cache",
                        "~/Library/Application Support/Google/Chrome/Default/Cache"
                    ],
                    "Safari": [
                        "~/Library/Caches/com.apple.Safari",
                        "~/Library/Safari/LocalStorage"
                    ]
                }
            }
        }

    def get(self, key_path, default=None):
        """ì  í‘œê¸°ë²•ìœ¼ë¡œ ì„¤ì • ê°’ ê°€ì ¸ì˜¤ê¸°"""
        keys = key_path.split('.')
        value = self.config
        try:
            for key in keys:
                value = value[key]
            return value
        except (KeyError, TypeError):
            return default

    def save_config(self):
        """ì„¤ì • íŒŒì¼ ì €ì¥"""
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"ì„¤ì • ì €ì¥ ì‹¤íŒ¨: {e}")

    def get_all_blocked_websites(self):
        """ëª¨ë“  ì°¨ë‹¨í•  ì›¹ì‚¬ì´íŠ¸ ëª©ë¡ ë°˜í™˜"""
        websites = []
        for category, sites in self.get("blocked_websites", {}).items():
            websites.extend(sites)
        return websites

# ----- ì „ì—­ ì„¤ì • ì¸ìŠ¤í„´ìŠ¤ -----
config_manager = ConfigManager()

# ----- ì „ì—­ ìƒíƒœ í´ë˜ìŠ¤ -----
class FocusTimerState:
    def __init__(self):
        self.is_focus_mode = False
        self.focus_start_time = None
        self.focus_end_time = None
        self.is_blocked = False
        self.hosts_hash = None
        self.last_check = None
        self.block_count = 0
        self.bypass_attempts = 0
        self.difficulty_level = 1
        self.failed_attempts = 0

# ----- ë¡œê¹… ì‹œìŠ¤í…œ -----
class Logger:
    def __init__(self, log_file):
        self.log_file = log_file
        self.ensure_log_directory()

    def ensure_log_directory(self):
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)

    def log(self, level, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"

        # ì½˜ì†” ì¶œë ¥
        print(log_entry)

        # íŒŒì¼ ë¡œê¹…
        try:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")
        except:
            pass

# ----- ì‹œìŠ¤í…œ ë ˆë²¨ ë³´í˜¸ -----
class SystemProtection:
    def __init__(self):
        self.original_hosts_permissions = None
        self.firewall_rules = []
        self.logger = Logger(config_manager.get("system_paths.log_path"))

    def backup_hosts_permissions(self):
        """hosts íŒŒì¼ ì›ë³¸ ê¶Œí•œ ë°±ì—…"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            stat_info = os.stat(hosts_path)
            self.original_hosts_permissions = stat_info.st_mode
            self.logger.log("INFO", "hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì™„ë£Œ")
        except Exception as e:
            self.logger.log("ERROR", f"hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì‹¤íŒ¨: {e}")

    def lock_hosts_file(self):
        """hosts íŒŒì¼ì„ ì½ê¸° ì „ìš©ìœ¼ë¡œ ì ê¸ˆ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            os.chmod(hosts_path, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)  # 444
            self.logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ ì™„ë£Œ")
        except Exception as e:
            self.logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ ì‹¤íŒ¨: {e}")

    def unlock_hosts_file(self):
        """hosts íŒŒì¼ ì ê¸ˆ í•´ì œ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            if self.original_hosts_permissions:
                os.chmod(hosts_path, self.original_hosts_permissions)
            else:
                os.chmod(hosts_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)  # 644
            self.logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì™„ë£Œ")
        except Exception as e:
            self.logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì‹¤íŒ¨: {e}")

    def setup_firewall_rules(self):
        """ë°©í™”ë²½ ê·œì¹™ ì„¤ì •"""
        if not config_manager.get("security.enable_firewall_rules", False):
            return

        try:
            # pfctlì„ ì‚¬ìš©í•œ ë°©í™”ë²½ ê·œì¹™ ì¶”ê°€
            rules = []
            websites = config_manager.get_all_blocked_websites()

            for domain in websites:
                rules.append(f'block drop out proto tcp to {domain} port 80')
                rules.append(f'block drop out proto tcp to {domain} port 443')

            # ì„ì‹œ ê·œì¹™ íŒŒì¼ ìƒì„±
            rules_file = "/tmp/focus_timer_pf.conf"
            with open(rules_file, "w") as f:
                f.write("\n".join(rules))

            # ë°©í™”ë²½ ê·œì¹™ ì ìš©
            subprocess.run(["sudo", "pfctl", "-f", rules_file], check=True)
            subprocess.run(["sudo", "pfctl", "-e"], check=True)  # ë°©í™”ë²½ í™œì„±í™”

            self.firewall_rules = rules
            self.logger.log("INFO", f"ë°©í™”ë²½ ê·œì¹™ {len(rules)}ê°œ ì ìš© ì™„ë£Œ")

        except Exception as e:
            self.logger.log("ERROR", f"ë°©í™”ë²½ ê·œì¹™ ì„¤ì • ì‹¤íŒ¨: {e}")

    def remove_firewall_rules(self):
        """ë°©í™”ë²½ ê·œì¹™ ì œê±°"""
        if not config_manager.get("security.enable_firewall_rules", False):
            return

        try:
            subprocess.run(["sudo", "pfctl", "-d"], check=True)  # ë°©í™”ë²½ ë¹„í™œì„±í™”
            self.logger.log("INFO", "ë°©í™”ë²½ ê·œì¹™ ì œê±° ì™„ë£Œ")
        except Exception as e:
            self.logger.log("ERROR", f"ë°©í™”ë²½ ê·œì¹™ ì œê±° ì‹¤íŒ¨: {e}")

# ----- ì§€ì†ì  ëª¨ë‹ˆí„°ë§ -----
class HostsFileMonitor(FileSystemEventHandler):
    def __init__(self, focus_timer):
        self.focus_timer = focus_timer
        self.last_modified = 0
        self.logger = Logger(config_manager.get("system_paths.log_path"))

    def on_modified(self, event):
        hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
        if event.src_path == hosts_path:
            current_time = time.time()
            if current_time - self.last_modified > 1:  # ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€
                self.last_modified = current_time
                self.logger.log("WARNING", "hosts íŒŒì¼ ë³€ê²½ ê°ì§€ë¨")
                self.focus_timer.handle_hosts_modification()

class FocusTimerMonitor:
    def __init__(self):
        self.observer = None
        self.monitoring = False
        self.system_protection = SystemProtection()
        self.logger = Logger(config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log"))

    def start_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if not config_manager.get("security.monitor_hosts_changes", True):
            return

        try:
            self.observer = Observer()
            event_handler = HostsFileMonitor(self)
            hosts_path = config_manager.get("system_paths.hosts_file", "/etc/hosts")
            hosts_dir = os.path.dirname(hosts_path)
            self.observer.schedule(event_handler, path=hosts_dir, recursive=False)
            self.observer.start()
            self.monitoring = True
            self.logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        except Exception as e:
            self.logger.log("ERROR", f"ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì‹¤íŒ¨: {e}")

    def stop_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.monitoring = False
            self.logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€")

    def handle_hosts_modification(self):
        """hosts íŒŒì¼ ìˆ˜ì • ì²˜ë¦¬"""
        if state.is_focus_mode and state.is_blocked:
            self.logger.log("WARNING", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ hosts íŒŒì¼ ìˆ˜ì • ì‹œë„ ê°ì§€")
            state.bypass_attempts += 1

            # ìë™ìœ¼ë¡œ ì°¨ë‹¨ ì¬ì ìš©
            self.reapply_blocking()

            # ë³´ì•ˆ ê°•í™”
            self.enhance_security()

    def reapply_blocking(self):
        """ì°¨ë‹¨ ì¬ì ìš©"""
        try:
            # hosts íŒŒì¼ ì ê¸ˆ í•´ì œ
            self.system_protection.unlock_hosts_file()

            # ì°¨ë‹¨ ì„¤ì • ì¬ì ìš©
            block_websites()

            # hosts íŒŒì¼ ë‹¤ì‹œ ì ê¸ˆ
            if config_manager.get("security.lock_hosts_file", True):
                self.system_protection.lock_hosts_file()

            # DNS ìºì‹œ ì´ˆê¸°í™”
            if config_manager.get("security.enable_dns_cache_flush", True):
                self.flush_dns_cache()

            self.logger.log("INFO", "ì°¨ë‹¨ ì¬ì ìš© ì™„ë£Œ")

        except Exception as e:
            self.logger.log("ERROR", f"ì°¨ë‹¨ ì¬ì ìš© ì‹¤íŒ¨: {e}")

    def enhance_security(self):
        """ë³´ì•ˆ ê°•í™”"""
        try:
            # ë°©í™”ë²½ ê·œì¹™ ê°•í™”
            self.system_protection.setup_firewall_rules()

            # ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘
            if config_manager.get("focus_mode.force_browser_restart", True):
                self.restart_browsers()

            # ì‹œìŠ¤í…œ ì•Œë¦¼
            self.send_system_notification("ë³´ì•ˆ ê²½ê³ ", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ ì°¨ë‹¨ í•´ì œ ì‹œë„ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")

            self.logger.log("INFO", "ë³´ì•ˆ ê°•í™” ì™„ë£Œ")

        except Exception as e:
            self.logger.log("ERROR", f"ë³´ì•ˆ ê°•í™” ì‹¤íŒ¨: {e}")

    def flush_dns_cache(self):
        """DNS ìºì‹œ ì´ˆê¸°í™”"""
        try:
            subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
            subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
            self.logger.log("INFO", "DNS ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            self.logger.log("ERROR", f"DNS ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

    def restart_browsers(self):
        """ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘"""
        browsers = config_manager.get("browsers.supported", ["Google Chrome", "Safari", "Firefox", "Whale", "Microsoft Edge"])

        for browser in browsers:
            try:
                # ë¸Œë¼ìš°ì € ì¢…ë£Œ
                subprocess.run(["osascript", "-e", f'quit app "{browser}"'],
                             capture_output=True, timeout=5)
                time.sleep(2)

                # ê°•ì œ ì¢…ë£Œ
                subprocess.run(["pkill", "-f", browser], capture_output=True)
                time.sleep(1)

                # ì¬ì‹œì‘
                subprocess.run(["open", "-a", browser], capture_output=True)
                time.sleep(3)

                self.logger.log("INFO", f"{browser} ì¬ì‹œì‘ ì™„ë£Œ")

            except Exception as e:
                self.logger.log("ERROR", f"{browser} ì¬ì‹œì‘ ì‹¤íŒ¨: {e}")

    def send_system_notification(self, title, message):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        try:
            subprocess.run([
                "osascript", "-e",
                f'display notification "{message}" with title "{title}"'
            ], capture_output=True)
        except:
            pass

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
state = FocusTimerState()
challenge = None

# ----- ë¡œê¹… ì‹œìŠ¤í…œ -----
class Logger:
    def __init__(self, log_file):
        self.log_file = log_file
        self.ensure_log_directory()

    def ensure_log_directory(self):
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)

    def log(self, level, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] {message}"

        # ì½˜ì†” ì¶œë ¥
        print(log_entry)

        # íŒŒì¼ ë¡œê¹…
        try:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")
        except:
            pass

logger = Logger(config_manager.get("system_paths.log_path"))

# ----- ì‹œìŠ¤í…œ ë ˆë²¨ ë³´í˜¸ -----
class SystemProtection:
    def __init__(self):
        self.original_hosts_permissions = None
        self.firewall_rules = []

    def backup_hosts_permissions(self):
        """hosts íŒŒì¼ ì›ë³¸ ê¶Œí•œ ë°±ì—…"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            stat_info = os.stat(hosts_path)
            self.original_hosts_permissions = stat_info.st_mode
            logger.log("INFO", "hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ê¶Œí•œ ë°±ì—… ì‹¤íŒ¨: {e}")

    def lock_hosts_file(self):
        """hosts íŒŒì¼ì„ ì½ê¸° ì „ìš©ìœ¼ë¡œ ì ê¸ˆ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            os.chmod(hosts_path, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)  # 444
            logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ ì‹¤íŒ¨: {e}")

    def unlock_hosts_file(self):
        """hosts íŒŒì¼ ì ê¸ˆ í•´ì œ"""
        try:
            hosts_path = config_manager.get("system_paths.hosts_file")
            if self.original_hosts_permissions:
                os.chmod(hosts_path, self.original_hosts_permissions)
            else:
                os.chmod(hosts_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)  # 644
            logger.log("INFO", "hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"hosts íŒŒì¼ ì ê¸ˆ í•´ì œ ì‹¤íŒ¨: {e}")

# ----- ì§€ì†ì  ëª¨ë‹ˆí„°ë§ -----
class HostsFileMonitor(FileSystemEventHandler):
    def __init__(self, focus_timer):
        self.focus_timer = focus_timer
        self.last_modified = 0

    def on_modified(self, event):
        hosts_path = config_manager.get("system_paths.hosts_file")
        if event.src_path == hosts_path:
            current_time = time.time()
            if current_time - self.last_modified > 1:  # ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€
                self.last_modified = current_time
                logger.log("WARNING", "hosts íŒŒì¼ ë³€ê²½ ê°ì§€ë¨")
                self.focus_timer.handle_hosts_modification()

class FocusTimerMonitor:
    def __init__(self):
        self.observer = None
        self.monitoring = False
        self.system_protection = SystemProtection()

    def start_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if not config_manager.get("security.enable_file_monitoring", True):
            return

        try:
            self.observer = Observer()
            event_handler = HostsFileMonitor(self)
            self.observer.schedule(event_handler, path="/etc", recursive=False)
            self.observer.start()
            self.monitoring = True
            logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        except Exception as e:
            logger.log("ERROR", f"ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì‹¤íŒ¨: {e}")

    def stop_monitoring(self):
        """íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.monitoring = False
            logger.log("INFO", "íŒŒì¼ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€")

    def handle_hosts_modification(self):
        """hosts íŒŒì¼ ìˆ˜ì • ì²˜ë¦¬"""
        if state.is_focus_mode and state.is_blocked:
            logger.log("WARNING", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ hosts íŒŒì¼ ìˆ˜ì • ì‹œë„ ê°ì§€")
            state.bypass_attempts += 1

            # ìë™ìœ¼ë¡œ ì°¨ë‹¨ ì¬ì ìš©
            self.reapply_blocking()

            # ë³´ì•ˆ ê°•í™”
            self.enhance_security()

    def reapply_blocking(self):
        """ì°¨ë‹¨ ì¬ì ìš©"""
        try:
            # hosts íŒŒì¼ ì ê¸ˆ í•´ì œ
            self.system_protection.unlock_hosts_file()

            # ì°¨ë‹¨ ì„¤ì • ì¬ì ìš©
            block_websites()

            # hosts íŒŒì¼ ë‹¤ì‹œ ì ê¸ˆ
            if config_manager.get("security.lock_hosts_file", True):
                self.system_protection.lock_hosts_file()

            # DNS ìºì‹œ ì´ˆê¸°í™”
            if config_manager.get("security.enable_dns_cache_flush", True):
                self.flush_dns_cache()

            logger.log("INFO", "ì°¨ë‹¨ ì¬ì ìš© ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ì°¨ë‹¨ ì¬ì ìš© ì‹¤íŒ¨: {e}")

    def enhance_security(self):
        """ë³´ì•ˆ ê°•í™”"""
        try:
            # ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘
            if config_manager.get("focus_mode.force_browser_restart", True):
                self.restart_browsers()

            # ì‹œìŠ¤í…œ ì•Œë¦¼
            self.send_system_notification("ë³´ì•ˆ ê²½ê³ ", "ì§‘ì¤‘ ëª¨ë“œ ì¤‘ ì°¨ë‹¨ í•´ì œ ì‹œë„ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")

            logger.log("INFO", "ë³´ì•ˆ ê°•í™” ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ë³´ì•ˆ ê°•í™” ì‹¤íŒ¨: {e}")

    def flush_dns_cache(self):
        """DNS ìºì‹œ ì´ˆê¸°í™”"""
        try:
            subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
            subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
            logger.log("INFO", "DNS ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            logger.log("ERROR", f"DNS ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

    def restart_browsers(self):
        """ë¸Œë¼ìš°ì € ê°•ì œ ì¬ì‹œì‘"""
        browsers = config_manager.get("browsers.supported", [])

        for browser in browsers:
            try:
                # ë¸Œë¼ìš°ì € ì¢…ë£Œ
                subprocess.run(["osascript", "-e", f'quit app "{browser}"'],
                             capture_output=True, timeout=5)
                time.sleep(2)

                # ê°•ì œ ì¢…ë£Œ
                subprocess.run(["pkill", "-f", browser], capture_output=True)
                time.sleep(1)

                # ì¬ì‹œì‘
                subprocess.run(["open", "-a", browser], capture_output=True)
                time.sleep(3)

                logger.log("INFO", f"{browser} ì¬ì‹œì‘ ì™„ë£Œ")

            except Exception as e:
                logger.log("ERROR", f"{browser} ì¬ì‹œì‘ ì‹¤íŒ¨: {e}")

    def send_system_notification(self, title, message):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        try:
            subprocess.run([
                "osascript", "-e",
                f'display notification "{message}" with title "{title}"'
            ], capture_output=True)
        except:
            pass

# ----- ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì‹œìŠ¤í…œ -----
class AlgorithmChallenge:
    def __init__(self):
        self.difficulty_level = config_manager.get("focus_mode.default_difficulty", 1)
        self.max_attempts = config_manager.get("focus_mode.max_attempts", 3)
        self.failed_attempts = 0

    def generate_problem(self):
        """ë‚œì´ë„ì— ë”°ë¥¸ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ìƒì„±"""
        if self.difficulty_level == 1:
            # ê¸°ë³¸ ì‚¬ì¹™ì—°ì‚°
            a = random.randint(10, 99)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 2:
            # 3ìë¦¬ ìˆ˜ ì—°ì‚°
            a = random.randint(100, 999)
            b = random.randint(10, 99)
            operation = random.choice(["+", "-", "*"])

            if operation == "+":
                answer = a + b
            elif operation == "-":
                answer = a - b
            else:
                answer = a * b

            return f"{a} {operation} {b} = ?", answer

        elif self.difficulty_level == 3:
            # ë³µí•© ì—°ì‚°
            a = random.randint(10, 50)
            b = random.randint(5, 20)
            c = random.randint(2, 10)

            answer = (a + b) * c
            return f"({a} + {b}) Ã— {c} = ?", answer

        elif self.difficulty_level == 4:
            # í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´
            n = random.randint(5, 10)
            fib_sequence = [0, 1]
            for i in range(2, n + 1):
                fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
            answer = fib_sequence[n]
            return f"í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì˜ {n}ë²ˆì§¸ ìˆ˜ëŠ”? (F(0)=0, F(1)=1)", answer

        else:  # ë‚œì´ë„ 5
            # ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ
            numbers = [random.randint(1, 100) for _ in range(5)]
            sorted_numbers = sorted(numbers)
            answer = sorted_numbers[2]  # ì¤‘ê°„ê°’
            return f"ìˆ«ì {numbers}ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í–ˆì„ ë•Œ ì¤‘ê°„ê°’ì€?", answer

    def increase_difficulty(self):
        """ë‚œì´ë„ ì¦ê°€"""
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        if self.difficulty_level < max_difficulty:
            self.difficulty_level += 1
            logger.log("INFO", f"ë‚œì´ë„ê°€ {self.difficulty_level}ë¡œ ì¦ê°€")

    def ask_challenge(self):
        """ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì¶œì œ ë° ì •ë‹µ í™•ì¸"""
        logger.log("INFO", f"ë‚œì´ë„ {self.difficulty_level} ë¬¸ì œ ì¶œì œ")

        attempts = 0
        while attempts < self.max_attempts:
            problem, answer = self.generate_problem()
            print(f"\nğŸ“ ë¬¸ì œ: {problem}")

            try:
                user_input = input("ë‹µ: ").strip()

                if user_input.isdigit():
                    user_answer = int(user_input)
                else:
                    print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                    attempts += 1
                    continue

                if user_answer == answer:
                    logger.log("INFO", "ë¬¸ì œ í•´ê²° ì„±ê³µ")
                    return True
                else:
                    attempts += 1
                    remaining = self.max_attempts - attempts
                    print(f"âŒ ì˜¤ë‹µì…ë‹ˆë‹¤. ì •ë‹µ: {answer}")
                    if remaining > 0:
                        print(f"ğŸ”„ ë‚¨ì€ ì‹œë„: {remaining}")
                    else:
                        print("ğŸš« ëª¨ë“  ì‹œë„ ì‹¤íŒ¨!")

            except KeyboardInterrupt:
                print("\nâš ï¸ ë¬¸ì œ í’€ì´ë¥¼ ì¤‘ë‹¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
                attempts += 1
            except:
                print("âš ï¸ ì˜¬ë°”ë¥¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                attempts += 1

        # ëª¨ë“  ì‹œë„ ì‹¤íŒ¨
        self.failed_attempts += 1
        if self.failed_attempts >= 2:
            self.increase_difficulty()
            self.failed_attempts = 0

        logger.log("WARNING", "ë¬¸ì œ í•´ê²° ì‹¤íŒ¨ - ì¢…ë£Œ ê±°ë¶€")
        return False

# ----- ë‹¤ì¤‘ ì°¨ë‹¨ ë ˆì´ì–´ -----
def block_websites():
    """ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ ì ìš©"""
    try:
        # 1. hosts íŒŒì¼ ì°¨ë‹¨
        block_hosts_file()

        # 2. ë°©í™”ë²½ ê·œì¹™ ì ìš©
        if config_manager.get("security.enable_firewall_rules", False):
            apply_firewall_rules()

        # 3. DNS ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        # 4. ë¸Œë¼ìš°ì € ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_browser_cache_clear", True):
            clear_browser_cache()

        state.is_blocked = True
        state.block_count += 1
        logger.log("INFO", "ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ ì ìš© ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ì°¨ë‹¨ ì ìš© ì‹¤íŒ¨: {e}")

def unblock_websites():
    """ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ í•´ì œ"""
    try:
        # 1. hosts íŒŒì¼ ë³µêµ¬
        restore_hosts_file()

        # 2. ë°©í™”ë²½ ê·œì¹™ ì œê±°
        if config_manager.get("security.enable_firewall_rules", False):
            remove_firewall_rules()

        # 3. DNS ìºì‹œ ì´ˆê¸°í™”
        if config_manager.get("security.enable_dns_cache_flush", True):
            flush_dns_cache()

        state.is_blocked = False
        logger.log("INFO", "ë‹¤ì¤‘ ë ˆì´ì–´ ì°¨ë‹¨ í•´ì œ ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ì°¨ë‹¨ í•´ì œ ì‹¤íŒ¨: {e}")

def apply_firewall_rules():
    """ë°©í™”ë²½ ê·œì¹™ ì ìš©"""
    try:
        # pfctlì„ ì‚¬ìš©í•œ ë°©í™”ë²½ ê·œì¹™
        rules = []
        websites = config_manager.get_all_blocked_websites()

        for domain in websites:
            rules.append(f'block drop out proto tcp to {domain} port 80')
            rules.append(f'block drop out proto tcp to {domain} port 443')

        rules_file = "/tmp/focus_timer_pf.conf"
        with open(rules_file, "w") as f:
            f.write("\n".join(rules))

        subprocess.run(["sudo", "pfctl", "-f", rules_file], check=True)
        subprocess.run(["sudo", "pfctl", "-e"], check=True)

        logger.log("INFO", "ë°©í™”ë²½ ê·œì¹™ ì ìš© ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ë°©í™”ë²½ ê·œì¹™ ì ìš© ì‹¤íŒ¨: {e}")

def remove_firewall_rules():
    """ë°©í™”ë²½ ê·œì¹™ ì œê±°"""
    try:
        subprocess.run(["sudo", "pfctl", "-d"], check=True)
        logger.log("INFO", "ë°©í™”ë²½ ê·œì¹™ ì œê±° ì™„ë£Œ")
    except Exception as e:
        logger.log("ERROR", f"ë°©í™”ë²½ ê·œì¹™ ì œê±° ì‹¤íŒ¨: {e}")

def block_hosts_file():
    """hosts íŒŒì¼ì— ì°¨ë‹¨ ì„¤ì • ì¶”ê°€"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")
        redirect_ip = config_manager.get("system_paths.redirect_ip")
        websites = config_manager.get_all_blocked_websites()

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            # FocusTimer ë¸”ë¡ ì‹œì‘/ë ë§ˆì»¤
            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            # ê¸°ì¡´ ë¸”ë¡ ì œê±°
            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                lines = lines[:start_idx] + lines[end_idx + 1:]

            # ìƒˆë¡œìš´ ì°¨ë‹¨ ì„¤ì • ì¶”ê°€
            new_entries = [block_start]
            for site in websites:
                new_entries.append(f"{redirect_ip} {site}\n")
            new_entries.append(block_end)

            # íŒŒì¼ì— ì“°ê¸°
            file.seek(0)
            file.writelines(lines + new_entries)
            file.truncate()
            file.flush()
            os.fsync(file.fileno())

            logger.log("INFO", "hosts íŒŒì¼ ì°¨ë‹¨ ì„¤ì • ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"hosts íŒŒì¼ ì°¨ë‹¨ ì‹¤íŒ¨: {e}")

def restore_hosts_file():
    """hosts íŒŒì¼ì—ì„œ ì°¨ë‹¨ ì„¤ì • ì œê±°"""
    try:
        hosts_path = config_manager.get("system_paths.hosts_file")

        with open(hosts_path, "r+") as file:
            lines = file.readlines()

            block_start = "# FocusTimer Block Start\n"
            block_end = "# FocusTimer Block End\n"

            start_idx = -1
            end_idx = -1
            for i, line in enumerate(lines):
                if line == block_start:
                    start_idx = i
                elif line == block_end:
                    end_idx = i
                    break

            if start_idx != -1 and end_idx != -1:
                new_lines = lines[:start_idx] + lines[end_idx + 1:]
                file.seek(0)
                file.writelines(new_lines)
                file.truncate()
                file.flush()
                os.fsync(file.fileno())

                logger.log("INFO", "hosts íŒŒì¼ ë³µêµ¬ ì™„ë£Œ")
            else:
                logger.log("INFO", "ì°¨ë‹¨ ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.")

    except Exception as e:
        logger.log("ERROR", f"hosts íŒŒì¼ ë³µêµ¬ ì‹¤íŒ¨: {e}")

def flush_dns_cache():
    """DNS ìºì‹œ ì´ˆê¸°í™”"""
    try:
        subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True)
        subprocess.run(["sudo", "killall", "-HUP", "mDNSResponder"], check=True)
        logger.log("INFO", "DNS ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
    except Exception as e:
        logger.log("ERROR", f"DNS ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

def clear_browser_cache():
    """ë¸Œë¼ìš°ì € ìºì‹œ ì´ˆê¸°í™”"""
    browsers = config_manager.get("browsers.supported", [])
    cache_paths = config_manager.get("browsers.cache_paths", {})

    for browser in browsers:
        try:
            if browser in cache_paths:
                for path in cache_paths[browser]:
                    expanded_path = os.path.expanduser(path)
                    if os.path.exists(expanded_path):
                        subprocess.run(["rm", "-rf", f"{expanded_path}/*"], capture_output=True)

            logger.log("INFO", f"{browser} ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"{browser} ìºì‹œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

# ----- ìƒíƒœ ê´€ë¦¬ -----
def save_state():
    """ìƒíƒœ ì €ì¥"""
    try:
        state_data = {
            "is_focus_mode": state.is_focus_mode,
            "focus_start_time": state.focus_start_time.isoformat() if state.focus_start_time else None,
            "focus_end_time": state.focus_end_time.isoformat() if state.focus_end_time else None,
            "is_blocked": state.is_blocked,
            "block_count": state.block_count,
            "bypass_attempts": state.bypass_attempts,
            "difficulty_level": challenge.difficulty_level if challenge else 1,
            "failed_attempts": challenge.failed_attempts if challenge else 0,
            "last_check": datetime.datetime.now().isoformat()
        }

        with open(config_manager.state_path, "w") as f:
            json.dump(state_data, f, indent=2)

        logger.log("INFO", "ìƒíƒœ ì €ì¥ ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: {e}")

def load_state():
    """ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°"""
    try:
        if os.path.exists(config_manager.state_path):
            with open(config_manager.state_path, "r") as f:
                state_data = json.load(f)

            state.is_focus_mode = state_data.get("is_focus_mode", False)
            state.is_blocked = state_data.get("is_blocked", False)
            state.block_count = state_data.get("block_count", 0)
            state.bypass_attempts = state_data.get("bypass_attempts", 0)

            if state_data.get("focus_start_time"):
                state.focus_start_time = datetime.datetime.fromisoformat(state_data["focus_start_time"])
            if state_data.get("focus_end_time"):
                state.focus_end_time = datetime.datetime.fromisoformat(state_data["focus_end_time"])

            if challenge:
                challenge.difficulty_level = state_data.get("difficulty_level", 1)
                challenge.failed_attempts = state_data.get("failed_attempts", 0)

            logger.log("INFO", "ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ")

    except Exception as e:
        logger.log("ERROR", f"ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

# ----- GUI ì• í”Œë¦¬ì¼€ì´ì…˜ -----
class FocusTimerApp:
    def __init__(self):
        global challenge
        challenge = AlgorithmChallenge()
        self.monitor = FocusTimerMonitor()
        self.running = False
        self.monitor_thread = None

        # GUI ì´ˆê¸°í™”
        self.root = tk.Tk()

        # macOS íŠ¹í™” GUI ì„¤ì •
        self.setup_macos_gui()
        self.setup_gui()

        # ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
        load_state()

        # ì‹œìŠ¤í…œ ë³´í˜¸ ì´ˆê¸°í™”
        if config_manager.get("security.enable_system_protection", True):
            self.monitor.system_protection.backup_hosts_permissions()

        # ëª¨ë‹ˆí„°ë§ ì‹œì‘
        if config_manager.get("security.monitor_hosts_changes", True):
            self.monitor.start_monitoring()

    def setup_macos_gui(self):
        """macOS íŠ¹í™” GUI ì„¤ì •"""
        try:
            # macOSì—ì„œ GUI ì°½ì„ ì•ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
            self.root.lift()
            self.root.attributes('-topmost', True)
            self.root.after_idle(self.root.attributes, '-topmost', False)

            # macOS ë„¤ì´í‹°ë¸Œ ë©”ë‰´ë°” ì„¤ì •
            self.root.createcommand('tk::mac::Quit', self.quit_app)
            self.root.createcommand('tk::mac::ShowPreferences', self.show_preferences)

            # ì°½ í¬ê¸° ì¡°ì • ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
            self.root.resizable(True, True)

            # macOS ìŠ¤íƒ€ì¼ ì ìš©
            self.root.tk.call('tk', 'scaling', 2.0)  # ê³ í•´ìƒë„ ë””ìŠ¤í”Œë ˆì´ ì§€ì›

        except Exception as e:
            logger.log("ERROR", f"macOS GUI ì„¤ì • ì‹¤íŒ¨: {e}")

    def show_preferences(self):
        """ì„¤ì • ì°½ í‘œì‹œ"""
        # ì„¤ì • íƒ­ìœ¼ë¡œ ì´ë™í•˜ëŠ” ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
        pass

    def setup_gui(self):
        """GUI ì„¤ì •"""
        app_name = config_manager.get("app_info.name", "FocusTimer")
        app_version = config_manager.get("app_info.version", "2.0.0")

        self.root.title(f"{app_name} v{app_version}")

        window_size = config_manager.get("gui_settings.window_size", {"width": 900, "height": 700})
        self.root.geometry(f"{window_size['width']}x{window_size['height']}")
        self.root.resizable(True, True)

        # ìŠ¤íƒ€ì¼ ì„¤ì •
        style = ttk.Style()
        theme = config_manager.get("gui_settings.theme", "clam")
        style.theme_use(theme)

        # ë©”ë‰´ë°” ì„¤ì •
        self.setup_menu()

        # ë©”ì¸ í”„ë ˆì„
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # ì œëª©
        title_label = ttk.Label(main_frame, text=f"â° {app_name}",
                               font=('Helvetica', 20, 'bold'))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))

        # íƒ­ ìƒì„±
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))

        # íƒ­ ì¶”ê°€
        self.create_dashboard_tab()
        self.create_timer_tab()
        self.create_settings_tab()
        self.create_stats_tab()
        self.create_logs_tab()

        # ìƒíƒœë°”
        self.status_var = tk.StringVar(value="ì¤€ë¹„ë¨")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var,
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))

        # ê·¸ë¦¬ë“œ ê°€ì¤‘ì¹˜
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)

    def setup_menu(self):
        """ë©”ë‰´ë°” ì„¤ì •"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # íŒŒì¼ ë©”ë‰´
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="íŒŒì¼", menu=file_menu)
        file_menu.add_command(label="ì„¤ì • ë‚´ë³´ë‚´ê¸°", command=self.export_config)
        file_menu.add_command(label="ì„¤ì • ê°€ì ¸ì˜¤ê¸°", command=self.import_config)
        file_menu.add_separator()
        file_menu.add_command(label="ì¢…ë£Œ", command=self.quit_app)

        # ë„êµ¬ ë©”ë‰´
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="ë„êµ¬", menu=tools_menu)
        tools_menu.add_command(label="CLI ëª¨ë“œ", command=self.open_cli)
        tools_menu.add_command(label="ì›¹ ì¸í„°í˜ì´ìŠ¤", command=self.open_web)
        tools_menu.add_separator()
        tools_menu.add_command(label="ë¡œê·¸ ë³´ê¸°", command=self.view_logs)

        # ë„ì›€ë§ ë©”ë‰´
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="ë„ì›€ë§", menu=help_menu)
        help_menu.add_command(label="ì‚¬ìš©ë²•", command=self.show_help)
        help_menu.add_command(label="ì •ë³´", command=self.show_about)

    def create_dashboard_tab(self):
        """ëŒ€ì‹œë³´ë“œ íƒ­"""
        dashboard_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(dashboard_frame, text="ğŸ“Š ëŒ€ì‹œë³´ë“œ")

        # í˜„ì¬ ìƒíƒœ
        status_frame = ttk.LabelFrame(dashboard_frame, text="ğŸ“Š í˜„ì¬ ìƒíƒœ", padding="10")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.status_label = ttk.Label(status_frame, text="ì§‘ì¤‘ ëª¨ë“œ ë¹„í™œì„±í™”",
                                     font=('Helvetica', 14))
        self.status_label.grid(row=0, column=0, sticky=tk.W)

        # ì‹œê°„ í‘œì‹œ
        self.time_var = tk.StringVar(value="")
        time_label = ttk.Label(status_frame, textvariable=self.time_var,
                              font=('Helvetica', 10))
        time_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        # ì‹¤ì‹œê°„ í†µê³„
        stats_frame = ttk.LabelFrame(dashboard_frame, text="ğŸ“ˆ ì‹¤ì‹œê°„ í†µê³„", padding="10")
        stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        # ì°¨ë‹¨ íšŸìˆ˜
        ttk.Label(stats_frame, text="ì°¨ë‹¨ íšŸìˆ˜:").grid(row=0, column=0, sticky=tk.W)
        self.block_count_var = tk.StringVar(value="0")
        ttk.Label(stats_frame, textvariable=self.block_count_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        # ìš°íšŒ ì‹œë„
        ttk.Label(stats_frame, text="ìš°íšŒ ì‹œë„:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        self.bypass_attempts_var = tk.StringVar(value="0")
        ttk.Label(stats_frame, textvariable=self.bypass_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # í˜„ì¬ ë‚œì´ë„
        ttk.Label(stats_frame, text="í˜„ì¬ ë‚œì´ë„:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        self.current_difficulty_var = tk.StringVar(value="1")
        ttk.Label(stats_frame, textvariable=self.current_difficulty_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # ë³´ì•ˆ ìƒíƒœ
        ttk.Label(stats_frame, text="ë³´ì•ˆ ìƒíƒœ:").grid(row=3, column=0, sticky=tk.W, pady=(5, 0))
        self.security_status_var = tk.StringVar(value="ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ í™œì„±í™”")
        ttk.Label(stats_frame, textvariable=self.security_status_var,
                 font=('Helvetica', 12, 'bold')).grid(row=3, column=1, padx=(10, 0), pady=(5, 0))

        # ë¹ ë¥¸ ì•¡ì…˜
        action_frame = ttk.LabelFrame(dashboard_frame, text="ğŸ¯ ë¹ ë¥¸ ì•¡ì…˜", padding="10")
        action_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Button(action_frame, text="ğŸš€ ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘",
                  command=self.start_focus_mode).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(action_frame, text="â¹ï¸ ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€",
                  command=self.stop_focus_mode).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(action_frame, text="ğŸ”’ ì¦‰ì‹œ ì°¨ë‹¨",
                  command=self.block_now).grid(row=0, column=2, padx=(0, 10))
        ttk.Button(action_frame, text="ğŸ”“ ì¦‰ì‹œ í•´ì œ",
                  command=self.unblock_now).grid(row=0, column=3)

    def create_timer_tab(self):
        """íƒ€ì´ë¨¸ ì„¤ì • íƒ­"""
        timer_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(timer_frame, text="â° íƒ€ì´ë¨¸")

        # ì‹œê°„ ì„¤ì •
        time_frame = ttk.LabelFrame(timer_frame, text="ì‹œê°„ ì„¤ì •", padding="10")
        time_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Label(time_frame, text="ì‹œì‘ ì‹œê°„:").grid(row=0, column=0, sticky=tk.W)
        self.start_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_start_time", "09:00"))
        ttk.Entry(time_frame, textvariable=self.start_time_var, width=10).grid(row=0, column=1, padx=(10, 0))

        ttk.Label(time_frame, text="ì¢…ë£Œ ì‹œê°„:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        self.end_time_var = tk.StringVar(value=config_manager.get("focus_mode.default_end_time", "18:00"))
        ttk.Entry(time_frame, textvariable=self.end_time_var, width=10).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # ë‚œì´ë„ ì„¤ì •
        difficulty_frame = ttk.LabelFrame(timer_frame, text="ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ë‚œì´ë„", padding="10")
        difficulty_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.difficulty_var = tk.IntVar(value=config_manager.get("focus_mode.default_difficulty", 1))
        max_difficulty = config_manager.get("focus_mode.max_difficulty", 5)
        for i in range(1, max_difficulty + 1):
            ttk.Radiobutton(difficulty_frame, text=f"ë‚œì´ë„ {i}",
                           variable=self.difficulty_var, value=i).grid(row=0, column=i-1, padx=(0, 10))

    def create_settings_tab(self):
        """ì„¤ì • íƒ­"""
        settings_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(settings_frame, text="âš™ï¸ ì„¤ì •")

        # ì¼ë°˜ ì„¤ì •
        general_frame = ttk.LabelFrame(settings_frame, text="ì¼ë°˜ ì„¤ì •", padding="10")
        general_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.auto_start_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(general_frame, text="ì‹œìŠ¤í…œ ì‹œì‘ ì‹œ ìë™ ì‹¤í–‰",
                       variable=self.auto_start_var).grid(row=0, column=0, sticky=tk.W)

        self.browser_restart_var = tk.BooleanVar(value=config_manager.get("focus_mode.auto_restart_browser", True))
        ttk.Checkbutton(general_frame, text="ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ ì‹œ ë¸Œë¼ìš°ì € ì¬ì‹œì‘",
                       variable=self.browser_restart_var).grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        # ë³´ì•ˆ ì„¤ì •
        security_frame = ttk.LabelFrame(settings_frame, text="ë³´ì•ˆ ì„¤ì •", padding="10")
        security_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.file_monitoring_var = tk.BooleanVar(value=config_manager.get("security.enable_file_monitoring", True))
        ttk.Checkbutton(security_frame, text="íŒŒì¼ ëª¨ë‹ˆí„°ë§ í™œì„±í™”",
                       variable=self.file_monitoring_var).grid(row=0, column=0, sticky=tk.W)

        self.auto_recovery_var = tk.BooleanVar(value=config_manager.get("security.enable_auto_recovery", True))
        ttk.Checkbutton(security_frame, text="ìë™ ë³µêµ¬ í™œì„±í™”",
                       variable=self.auto_recovery_var).grid(row=1, column=0, sticky=tk.W, pady=(5, 0))

        self.lock_hosts_var = tk.BooleanVar(value=config_manager.get("security.lock_hosts_file", True))
        ttk.Checkbutton(security_frame, text="hosts íŒŒì¼ ì ê¸ˆ",
                       variable=self.lock_hosts_var).grid(row=2, column=0, sticky=tk.W, pady=(5, 0))

        self.firewall_rules_var = tk.BooleanVar(value=config_manager.get("security.enable_firewall_rules", False))
        ttk.Checkbutton(security_frame, text="ë°©í™”ë²½ ê·œì¹™ ì ìš©",
                       variable=self.firewall_rules_var).grid(row=3, column=0, sticky=tk.W, pady=(5, 0))

        self.dns_flush_var = tk.BooleanVar(value=config_manager.get("security.enable_dns_cache_flush", True))
        ttk.Checkbutton(security_frame, text="DNS ìºì‹œ ì´ˆê¸°í™”",
                       variable=self.dns_flush_var).grid(row=4, column=0, sticky=tk.W, pady=(5, 0))

        self.browser_cache_var = tk.BooleanVar(value=config_manager.get("security.enable_browser_cache_clear", True))
        ttk.Checkbutton(security_frame, text="ë¸Œë¼ìš°ì € ìºì‹œ ì´ˆê¸°í™”",
                       variable=self.browser_cache_var).grid(row=5, column=0, sticky=tk.W, pady=(5, 0))

    def create_stats_tab(self):
        """í†µê³„ íƒ­"""
        stats_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(stats_frame, text="ğŸ“ˆ í†µê³„")

        # ê¸°ë³¸ í†µê³„
        basic_stats_frame = ttk.LabelFrame(stats_frame, text="ğŸ“Š ê¸°ë³¸ í†µê³„", padding="10")
        basic_stats_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.total_focus_time_var = tk.StringVar(value="0ì‹œê°„")
        ttk.Label(basic_stats_frame, text="ì´ ì§‘ì¤‘ ì‹œê°„:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(basic_stats_frame, textvariable=self.total_focus_time_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        self.block_count_var = tk.StringVar(value="0íšŒ")
        ttk.Label(basic_stats_frame, text="ì°¨ë‹¨ íšŸìˆ˜:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(basic_stats_frame, textvariable=self.block_count_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        self.bypass_attempts_var = tk.StringVar(value="0íšŒ")
        ttk.Label(basic_stats_frame, text="ìš°íšŒ ì‹œë„:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(basic_stats_frame, textvariable=self.bypass_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # ë³´ì•ˆ í†µê³„
        security_stats_frame = ttk.LabelFrame(stats_frame, text="ğŸ›¡ï¸ ë³´ì•ˆ í†µê³„", padding="10")
        security_stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.current_difficulty_var = tk.StringVar(value="1")
        ttk.Label(security_stats_frame, text="í˜„ì¬ ë‚œì´ë„:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(security_stats_frame, textvariable=self.current_difficulty_var,
                 font=('Helvetica', 12, 'bold')).grid(row=0, column=1, padx=(10, 0))

        self.security_status_var = tk.StringVar(value="ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ í™œì„±í™”")
        ttk.Label(security_stats_frame, text="ë³´ì•ˆ ìƒíƒœ:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(security_stats_frame, textvariable=self.security_status_var,
                 font=('Helvetica', 12, 'bold')).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        self.failed_attempts_var = tk.StringVar(value="0íšŒ")
        ttk.Label(security_stats_frame, text="ì‹¤íŒ¨í•œ ì‹œë„:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(security_stats_frame, textvariable=self.failed_attempts_var,
                 font=('Helvetica', 12, 'bold')).grid(row=2, column=1, padx=(10, 0), pady=(5, 0))

        # ì‹œìŠ¤í…œ í†µê³„
        system_stats_frame = ttk.LabelFrame(stats_frame, text="âš™ï¸ ì‹œìŠ¤í…œ í†µê³„", padding="10")
        system_stats_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        self.last_check_var = tk.StringVar(value="ì—†ìŒ")
        ttk.Label(system_stats_frame, text="ë§ˆì§€ë§‰ ì²´í¬:").grid(row=0, column=0, sticky=tk.W)
        ttk.Label(system_stats_frame, textvariable=self.last_check_var,
                 font=('Helvetica', 10)).grid(row=0, column=1, padx=(10, 0))

        self.monitoring_status_var = tk.StringVar(value="í™œì„±í™”")
        ttk.Label(system_stats_frame, text="ëª¨ë‹ˆí„°ë§ ìƒíƒœ:").grid(row=1, column=0, sticky=tk.W, pady=(5, 0))
        ttk.Label(system_stats_frame, textvariable=self.monitoring_status_var,
                 font=('Helvetica', 10)).grid(row=1, column=1, padx=(10, 0), pady=(5, 0))

        # í†µê³„ ì œì–´
        control_frame = ttk.Frame(stats_frame)
        control_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(10, 0))

        ttk.Button(control_frame, text="ğŸ”„ í†µê³„ ìƒˆë¡œê³ ì¹¨",
                  command=self.refresh_stats).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(control_frame, text="ğŸ“Š í†µê³„ ë‚´ë³´ë‚´ê¸°",
                  command=self.export_stats).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(control_frame, text="ğŸ—‘ï¸ í†µê³„ ì´ˆê¸°í™”",
                  command=self.reset_stats).grid(row=0, column=2)

    def create_logs_tab(self):
        """ë¡œê·¸ ë·°ì–´ íƒ­"""
        logs_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(logs_frame, text="ğŸ“ ì‹œìŠ¤í…œ ë¡œê·¸")

        # ë¡œê·¸ ì œì–´
        control_frame = ttk.Frame(logs_frame)
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))

        ttk.Button(control_frame, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨",
                  command=self.refresh_logs).grid(row=0, column=0, padx=(0, 10))
        ttk.Button(control_frame, text="ğŸ—‘ï¸ ë¡œê·¸ ì§€ìš°ê¸°",
                  command=self.clear_logs).grid(row=0, column=1, padx=(0, 10))
        ttk.Button(control_frame, text="ğŸ’¾ ë¡œê·¸ ì €ì¥",
                  command=self.save_logs).grid(row=0, column=2)

        # ë¡œê·¸ í‘œì‹œ
        log_frame = ttk.LabelFrame(logs_frame, text="ì‹¤ì‹œê°„ ë¡œê·¸", padding="10")
        log_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))

        # ë¡œê·¸ í…ìŠ¤íŠ¸ ìœ„ì ¯
        self.log_text = tk.Text(log_frame, height=15, width=80, font=('Courier', 9))
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=log_scrollbar.set)

        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        log_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

        # ë¡œê·¸ í”„ë ˆì„ ê·¸ë¦¬ë“œ ê°€ì¤‘ì¹˜
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        logs_frame.columnconfigure(0, weight=1)
        logs_frame.rowconfigure(1, weight=1)

    def refresh_logs(self):
        """ë¡œê·¸ ìƒˆë¡œê³ ì¹¨"""
        try:
            log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
            if os.path.exists(log_path):
                with open(log_path, 'r', encoding='utf-8') as f:
                    logs = f.readlines()[-50:]  # ìµœê·¼ 50ì¤„

                self.log_text.delete(1.0, tk.END)
                for log in logs:
                    self.log_text.insert(tk.END, log)

                self.log_text.see(tk.END)
            else:
                self.log_text.delete(1.0, tk.END)
                self.log_text.insert(tk.END, "ë¡œê·¸ íŒŒì¼ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n")
        except Exception as e:
            self.log_text.delete(1.0, tk.END)
            self.log_text.insert(tk.END, f"ë¡œê·¸ ì½ê¸° ì‹¤íŒ¨: {e}\n")

    def clear_logs(self):
        """ë¡œê·¸ ì§€ìš°ê¸°"""
        if messagebox.askyesno("í™•ì¸", "ë¡œê·¸ë¥¼ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?"):
            try:
                log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
                if os.path.exists(log_path):
                    with open(log_path, 'w') as f:
                        f.write("")
                    self.refresh_logs()
                    messagebox.showinfo("ì„±ê³µ", "ë¡œê·¸ê°€ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.")
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"ë¡œê·¸ ì§€ìš°ê¸° ì‹¤íŒ¨: {e}")

    def save_logs(self):
        """ë¡œê·¸ ì €ì¥"""
        try:
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".log",
                filetypes=[("Log files", "*.log"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                log_path = config_manager.get("system_paths.log_path", "/var/log/FocusTimer/focus_timer.log")
                if os.path.exists(log_path):
                    import shutil
                    shutil.copy2(log_path, filename)
                    messagebox.showinfo("ì„±ê³µ", f"ë¡œê·¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
                else:
                    messagebox.showwarning("ê²½ê³ ", "ë¡œê·¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}")

    def refresh_stats(self):
        """í†µê³„ ìƒˆë¡œê³ ì¹¨"""
        try:
            self.update_stats()
            messagebox.showinfo("ì„±ê³µ", "í†µê³„ê°€ ìƒˆë¡œê³ ì¹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"í†µê³„ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨: {e}")

    def export_stats(self):
        """í†µê³„ ë‚´ë³´ë‚´ê¸°"""
        try:
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("Text files", "*.txt"), ("All files", "*.*")]
            )
            if filename:
                stats_data = {
                    "timestamp": datetime.datetime.now().isoformat(),
                    "basic_stats": {
                        "total_focus_time": self.total_focus_time_var.get(),
                        "block_count": self.block_count_var.get(),
                        "bypass_attempts": self.bypass_attempts_var.get()
                    },
                    "security_stats": {
                        "current_difficulty": self.current_difficulty_var.get(),
                        "security_status": self.security_status_var.get(),
                        "failed_attempts": self.failed_attempts_var.get()
                    },
                    "system_stats": {
                        "last_check": self.last_check_var.get(),
                        "monitoring_status": self.monitoring_status_var.get()
                    }
                }

                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(stats_data, f, indent=2, ensure_ascii=False)

                messagebox.showinfo("ì„±ê³µ", f"í†µê³„ê°€ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤: {filename}")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"í†µê³„ ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: {e}")

    def reset_stats(self):
        """í†µê³„ ì´ˆê¸°í™”"""
        if messagebox.askyesno("í™•ì¸", "ëª¨ë“  í†µê³„ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            try:
                # ìƒíƒœ ì´ˆê¸°í™”
                state.block_count = 0
                state.bypass_attempts = 0
                if challenge:
                    challenge.failed_attempts = 0

                # GUI ì—…ë°ì´íŠ¸
                self.update_stats()

                # ìƒíƒœ ì €ì¥
                save_state()

                messagebox.showinfo("ì„±ê³µ", "í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"í†µê³„ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

    def start_focus_mode(self):
        """ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘"""
        try:
            # ì‹œê°„ íŒŒì‹±
            start_time = self.start_time_var.get()
            end_time = self.end_time_var.get()

            start_hour, start_minute = map(int, start_time.split(':'))
            end_hour, end_minute = map(int, end_time.split(':'))

            # ìƒíƒœ ì„¤ì •
            now = datetime.datetime.now()
            state.focus_start_time = now.replace(hour=start_hour, minute=start_minute, second=0, microsecond=0)
            state.focus_end_time = now.replace(hour=end_hour, minute=end_minute, second=0, microsecond=0)
            state.is_focus_mode = True

            if challenge:
                challenge.difficulty_level = self.difficulty_var.get()

            save_state()

            # ëª¨ë‹ˆí„°ë§ ì‹œì‘
            if not self.running:
                self.start_monitoring()

            self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ í™œì„±í™”")
            self.status_var.set("ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ë¨")
            messagebox.showinfo("ì„±ê³µ", "ì§‘ì¤‘ ëª¨ë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!")

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ ì‹¤íŒ¨: {e}")

    def stop_focus_mode(self):
        """ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€"""
        try:
            state.is_focus_mode = False
            state.is_blocked = False

            # ì°¨ë‹¨ í•´ì œ
            unblock_websites()

            save_state()

            self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ ë¹„í™œì„±í™”")
            self.status_var.set("ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€ë¨")
            messagebox.showinfo("ì„±ê³µ", "ì§‘ì¤‘ ëª¨ë“œê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!")

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€ ì‹¤íŒ¨: {e}")

    def block_now(self):
        """ì¦‰ì‹œ ì°¨ë‹¨"""
        try:
            block_websites()
            messagebox.showinfo("ì•Œë¦¼", "ì›¹ì‚¬ì´íŠ¸ê°€ ì¦‰ì‹œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤!")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì¦‰ì‹œ ì°¨ë‹¨ ì‹¤íŒ¨: {e}")

    def unblock_now(self):
        """ì¦‰ì‹œ í•´ì œ"""
        try:
            unblock_websites()
            messagebox.showinfo("ì•Œë¦¼", "ì›¹ì‚¬ì´íŠ¸ ì°¨ë‹¨ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤!")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"ì¦‰ì‹œ í•´ì œ ì‹¤íŒ¨: {e}")

    def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if not self.running:
            self.running = True
            self.monitor.start_monitoring()

            # ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘
            self.monitor_thread = threading.Thread(target=self.monitoring_loop, daemon=True)
            self.monitor_thread.start()

    def monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while self.running:
            try:
                self.check_focus_time()
                time.sleep(60)  # 1ë¶„ë§ˆë‹¤ ì²´í¬
            except Exception as e:
                logger.log("ERROR", f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {e}")

    def check_focus_time(self):
        """ì§‘ì¤‘ ì‹œê°„ ì²´í¬"""
        if not state.is_focus_mode:
            return

        now = datetime.datetime.now()
        current_time = now.time()

        if state.focus_start_time and state.focus_end_time:
            start_time = state.focus_start_time.time()
            end_time = state.focus_end_time.time()

            # ì‹œê°„ëŒ€ ë¹„êµ
            if start_time <= end_time:
                should_be_blocked = start_time <= current_time <= end_time
            else:
                should_be_blocked = current_time >= start_time or current_time <= end_time

            # ìƒíƒœ ë³€ê²½ ì²˜ë¦¬
            if state.is_blocked != should_be_blocked:
                if should_be_blocked:
                    block_websites()
                    self.monitor.system_protection.lock_hosts_file()
                    logger.log("INFO", "ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ - ì°¨ë‹¨ ì ìš©")
                else:
                    unblock_websites()
                    self.monitor.system_protection.unlock_hosts_file()
                    logger.log("INFO", "ì§‘ì¤‘ ëª¨ë“œ ì¢…ë£Œ - ì°¨ë‹¨ í•´ì œ")

                state.is_blocked = should_be_blocked
                save_state()

    def update_stats(self):
        """í†µê³„ ì—…ë°ì´íŠ¸"""
        try:
            # ê¸°ë³¸ í†µê³„
            self.block_count_var.set(f"{state.block_count}íšŒ")
            self.bypass_attempts_var.set(f"{state.bypass_attempts}íšŒ")
            self.current_difficulty_var.set(str(challenge.difficulty_level if challenge else 1))

            # ë³´ì•ˆ ìƒíƒœ
            if self.monitor.monitoring:
                self.security_status_var.set("ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ í™œì„±í™”")
            else:
                self.security_status_var.set("ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë¹„í™œì„±í™”")

            # ì‹œê°„ í‘œì‹œ
            if state.focus_start_time and state.focus_end_time:
                start_str = state.focus_start_time.strftime("%H:%M")
                end_str = state.focus_end_time.strftime("%H:%M")
                self.time_var.set(f"ì„¤ì • ì‹œê°„: {start_str} ~ {end_str}")
            else:
                self.time_var.set("")

            # ìƒíƒœ í‘œì‹œ
            if state.is_focus_mode:
                if state.is_blocked:
                    self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ í™œì„±í™” (ì°¨ë‹¨ ì¤‘)")
                else:
                    self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ í™œì„±í™” (ëŒ€ê¸° ì¤‘)")
            else:
                self.status_label.config(text="ì§‘ì¤‘ ëª¨ë“œ ë¹„í™œì„±í™”")

            # ì¶”ê°€ í†µê³„ ì—…ë°ì´íŠ¸
            self.failed_attempts_var.set(f"{challenge.failed_attempts if challenge else 0}íšŒ")

            # ë§ˆì§€ë§‰ ì²´í¬ ì‹œê°„
            if state.last_check:
                self.last_check_var.set(state.last_check.strftime("%Y-%m-%d %H:%M:%S"))
            else:
                self.last_check_var.set("ì—†ìŒ")

            # ëª¨ë‹ˆí„°ë§ ìƒíƒœ
            if self.monitor.monitoring:
                self.monitoring_status_var.set("í™œì„±í™”")
            else:
                self.monitoring_status_var.set("ë¹„í™œì„±í™”")

            # ë¡œê·¸ ì—…ë°ì´íŠ¸ (ë¡œê·¸ íƒ­ì´ í™œì„±í™”ëœ ê²½ìš°)
            try:
                current_tab = self.notebook.select()
                if "ë¡œê·¸" in self.notebook.tab(current_tab, "text"):
                    self.refresh_logs()
            except:
                pass

        except Exception as e:
            logger.log("ERROR", f"í†µê³„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")

    def export_config(self):
        """ì„¤ì • ë‚´ë³´ë‚´ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì„¤ì • ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥")

    def import_config(self):
        """ì„¤ì • ê°€ì ¸ì˜¤ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì„¤ì • ê°€ì ¸ì˜¤ê¸° ê¸°ëŠ¥")

    def open_cli(self):
        """CLI ëª¨ë“œ ì—´ê¸°"""
        cli_path = APP_ROOT / "MacOS" / "FocusTimerCLI"
        if cli_path.exists():
            try:
                subprocess.Popen([str(PYTHON_PATH), str(cli_path)])
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"CLI ëª¨ë“œ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        else:
            messagebox.showerror("ì˜¤ë¥˜", f"CLI íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {cli_path}")

    def open_web(self):
        """ì›¹ ì¸í„°í˜ì´ìŠ¤ ì—´ê¸°"""
        messagebox.showinfo("ì•Œë¦¼", "ì›¹ ì¸í„°í˜ì´ìŠ¤ê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦½ë‹ˆë‹¤!")

    def view_logs(self):
        """ë¡œê·¸ ë³´ê¸°"""
        log_path = LOG_PATH
        if os.path.exists(log_path):
            try:
                subprocess.run(["open", "-a", "Console", log_path])
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", f"ë¡œê·¸ íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨: {e}")
        else:
            messagebox.showinfo("ì•Œë¦¼", "ë¡œê·¸ íŒŒì¼ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

    def show_help(self):
        """ë„ì›€ë§ ë³´ê¸°"""
        messagebox.showinfo("ë„ì›€ë§", "FocusTimer ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”!")

    def show_about(self):
        """ì •ë³´ ë³´ê¸°"""
        messagebox.showinfo("ì •ë³´", f"{PRODUCT_NAME} v{VERSION}\nì§‘ì¤‘ ëª¨ë“œ ì‹œìŠ¤í…œ")

    def quit_app(self):
        """ì•± ì¢…ë£Œ"""
        if messagebox.askyesno("í™•ì¸", "ì•±ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            self.cleanup()
            self.root.quit()

    def cleanup(self):
        """ì •ë¦¬ ì‘ì—…"""
        try:
            self.running = False

            # ì°¨ë‹¨ í•´ì œ
            if state.is_blocked:
                unblock_websites()

            # hosts íŒŒì¼ ì ê¸ˆ í•´ì œ
            self.monitor.system_protection.unlock_hosts_file()

            # ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
            self.monitor.stop_monitoring()

            # ìƒíƒœ ì €ì¥
            save_state()

            logger.log("INFO", "ì •ë¦¬ ì‘ì—… ì™„ë£Œ")

        except Exception as e:
            logger.log("ERROR", f"ì •ë¦¬ ì‘ì—… ì‹¤íŒ¨: {e}")

    def run(self):
        """ì•± ì‹¤í–‰"""
        # ì£¼ê¸°ì  ì—…ë°ì´íŠ¸
        def update_loop():
            while True:
                try:
                    self.update_stats()
                    refresh_interval = config_manager.get("gui_settings.auto_refresh_interval", 5)
                    time.sleep(refresh_interval)  # ì„¤ì •ëœ ê°„ê²©ìœ¼ë¡œ ì—…ë°ì´íŠ¸
                except:
                    break

        update_thread = threading.Thread(target=update_loop, daemon=True)
        update_thread.start()

        # GUI ì‹¤í–‰
        self.root.mainloop()

# ----- ë©”ì¸ ì‹¤í–‰ -----
if __name__ == "__main__":
    if os.geteuid() != 0:
        print("âš ï¸ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤: sudo python3 FocusTimer")
        sys.exit(1)

    # GUI í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (sudo ì‹¤í–‰ ì‹œ í•„ìš”)
    try:
        # í˜„ì¬ ì‚¬ìš©ìì˜ GUI í™˜ê²½ ë³€ìˆ˜ ê°€ì ¸ì˜¤ê¸°
        user = os.environ.get('SUDO_USER', os.environ.get('USER'))
        if user:
            # macOS GUI í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
            os.environ['DISPLAY'] = ':0'
            os.environ['XAUTHORITY'] = f"/Users/{user}/.Xauthority"

            # Tkinter GUI í™˜ê²½ ì„¤ì •
            os.environ['TK_SILENCE_DEPRECATION'] = '1'

            # macOS íŠ¹í™” ì„¤ì •
            os.environ['NSDocumentRevisionsDebugMode'] = 'true'

    except Exception as e:
        print(f"GUI í™˜ê²½ ë³€ìˆ˜ ì„¤ì • ì‹¤íŒ¨: {e}")

    # ë””ë ‰í† ë¦¬ ìƒì„±
    os.makedirs(os.path.dirname(STATE_PATH), exist_ok=True)
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

    # GUI ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
    try:
        print("ğŸš€ FocusTimer GUI ì‹œì‘ ì¤‘...")
        app = FocusTimerApp()
        print("âœ… GUI ì´ˆê¸°í™” ì™„ë£Œ")
        print("ğŸ–¥ï¸ GUI ì°½ì´ í‘œì‹œë©ë‹ˆë‹¤. ì°½ì´ ë³´ì´ì§€ ì•Šìœ¼ë©´ Dockì„ í™•ì¸í•´ì£¼ì„¸ìš”.")
        app.run()
    except Exception as e:
        print(f"âŒ GUI ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        logger.log("ERROR", f"GUI ì‹¤í–‰ ì‹¤íŒ¨: {e}")

        # GUI ì‹¤íŒ¨ ì‹œ CLI ëª¨ë“œë¡œ ì „í™˜
        print("ğŸ”„ CLI ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤...")
        try:
            # CLI ëª¨ë“œ ì‹¤í–‰ ë¡œì§
            while True:
                print("\nğŸ“Š FocusTimer CLI ëª¨ë“œ")
                print("1. ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘")
                print("2. ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€")
                print("3. ì¦‰ì‹œ ì°¨ë‹¨")
                print("4. ì¦‰ì‹œ í•´ì œ")
                print("5. ìƒíƒœ í™•ì¸")
                print("6. ì¢…ë£Œ")

                choice = input("\nì„ íƒí•˜ì„¸ìš” (1-6): ").strip()

                if choice == "1":
                    # ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘ ë¡œì§
                    print("ğŸš€ ì§‘ì¤‘ ëª¨ë“œ ì‹œì‘")
                elif choice == "2":
                    # ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€ ë¡œì§
                    print("â¹ï¸ ì§‘ì¤‘ ëª¨ë“œ ì¤‘ì§€")
                elif choice == "3":
                    # ì¦‰ì‹œ ì°¨ë‹¨ ë¡œì§
                    print("ğŸ”’ ì¦‰ì‹œ ì°¨ë‹¨")
                elif choice == "4":
                    # ì¦‰ì‹œ í•´ì œ ë¡œì§
                    print("ğŸ”“ ì¦‰ì‹œ í•´ì œ")
                elif choice == "5":
                    # ìƒíƒœ í™•ì¸ ë¡œì§
                    print("ğŸ“Š ìƒíƒœ í™•ì¸")
                elif choice == "6":
                    print("ğŸ‘‹ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                    break
                else:
                    print("âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.")

        except KeyboardInterrupt:
            print("\nğŸ‘‹ ì¢…ë£Œí•©ë‹ˆë‹¤.")
    except KeyboardInterrupt:
        pass
    finally:
        try:
            app.cleanup()
        except:
            pass